
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Tactics & Treats â€“ Multi-Business Admin Bot (Full)</title>

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;800&display=swap" rel="stylesheet">

<style>
  :root{
    --bg:#0b0b0b; --panel:#141414; --panel2:#0f0f0f;
    --text:#fff; --muted:#c9c9c9; --accent:#ff2a2a;
    --line:#2a2a2a; --radius:16px;
  }
  *{ box-sizing:border-box; }
  body{
    margin:0; padding:16px;
    background:var(--bg); color:var(--text);
    font-family:"Poppins",system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
  }
  .wrap{ max-width:1060px; margin:0 auto; }
  header{
    display:flex; align-items:center; justify-content:space-between;
    gap:12px; flex-wrap:wrap; margin-bottom:12px;
  }
  h1{ margin:0; color:var(--accent); font-size:20px; }
  .pill{
    font-size:12px; padding:6px 10px; border-radius:999px;
    background:#1f1f1f; border:1px solid #2a2a2a; color:var(--muted);
  }
  .card{
    background:var(--panel);
    border:1px solid #262626;
    border-radius:var(--radius);
    padding:14px;
    box-shadow:0 0 18px rgba(255,0,0,.14);
  }
  .chat{
    height:62vh; min-height:380px; max-height:760px;
    overflow:auto;
    padding:12px;
    border-radius:14px;
    background:#000;
    border:1px solid var(--line);
  }
  .msg{
    max-width:94%;
    padding:10px 12px;
    border-radius:14px;
    margin:10px 0;
    white-space:pre-line;
    line-height:1.35;
    word-break:break-word;
  }
  .bot{
    background:#101010;
    border:1px solid #2a2a2a;
    border-top-left-radius:6px;
  }
  .user{
    background:#1c1c1c;
    border:1px solid #333;
    margin-left:auto;
    border-top-right-radius:6px;
  }
  .chips{
    display:flex; flex-wrap:wrap; gap:8px; margin-top:10px;
  }
  .chip{
    background:#191919;
    border:1px solid #2f2f2f;
    color:#fff;
    padding:8px 10px;
    border-radius:999px;
    cursor:pointer;
    font-size:13px;
    font-weight:800;
    user-select:none;
  }
  .chip:hover{ filter:brightness(1.08); }
  .bar{ display:flex; gap:10px; margin-top:10px; }
  input{
    flex:1;
    border:none; outline:none;
    border-radius:14px;
    padding:12px 12px;
    font-size:15px;
    color:#fff;
    background:var(--panel2);
    border:1px solid var(--line);
  }
  button{
    border:none;
    border-radius:14px;
    padding:12px 14px;
    font-weight:900;
    cursor:pointer;
    background:var(--accent);
    color:#fff;
  }
  button:hover{ filter:brightness(1.08); }
  .secondary{
    background:#242424;
    border:1px solid #343434;
    color:#fff;
  }
  #status{
    margin-top:10px;
    color:#ffb347;
    font-weight:800;
    min-height:18px;
    white-space:pre-line;
  }
  .meta{
    font-size:12px; color:var(--muted); margin-top:10px; line-height:1.35;
  }
  .meta b{ color:#fff; }
</style>
</head>

<body>
<div class="wrap">
  <header>
    <h1>Multi-Business Admin Bot</h1>
    <div class="pill">Auto 5-digit business code â€¢ Owner/Manager/Staff â€¢ Assign + Notes + Rules + Checklist</div>
  </header>

  <div class="card">
    <div id="chat" class="chat"></div>
    <div id="chips" class="chips"></div>
    <div id="status"></div>

    <div class="bar">
      <input id="input" placeholder='Try: NEWBIZ TacticsTreats mypass | LOGIN 12345 owner mypass | HELP' autocomplete="off" />
      <button id="sendBtn" type="button">Send</button>
      <button id="resetBtn" type="button" class="secondary">Reset</button>
    </div>

    <div class="meta">
      Quick: <b>HELP</b>, <b>WHOAMI</b>, <b>NEWBIZ</b>, <b>LOGIN</b>, <b>LISTUSERS</b>, <b>NEXT</b>, <b>UNPAID</b>, <b>UNFINISHED</b>, <b>SHOWALL</b>, <b>ASSIGN</b>, <b>CHECKLIST</b>, <b>DONE</b>
    </div>
  </div>
</div>

<!-- Firebase compat (best for plain HTML) -->
<script src="https://www.gstatic.com/firebasejs/11.0.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/11.0.1/firebase-firestore-compat.js"></script>

<script>
/* =========================================================
   IMPORTANT NOTE
   If you open this as file:// on Chromebook, Firebase often fails.
   Best: run a tiny local server (Live Server, or python http.server).
========================================================= */
if (location.protocol === "file:") {
  console.warn("Opened as file:// â€” Firebase may fail. Use a local server.");
}

/* =========================
   FIREBASE CONFIG (yours)
========================= */
firebase.initializeApp({
  apiKey:"AIzaSyCiZuaANb1lrgdn-aARGJ_TRhgzPPUug58",
  authDomain:"bracelets-and-color.firebaseapp.com",
  projectId:"bracelets-and-color",
  storageBucket:"bracelets-and-color.appspot.com",
  messagingSenderId:"382292570673",
  appId:"1:382292570673:web:1c966e2e7e8fc2efa31b10"
});
const db = firebase.firestore();
const ts = () => firebase.firestore.FieldValue.serverTimestamp();

/* =========================
   UI
========================= */
const chat = document.getElementById("chat");
const input = document.getElementById("input");
const chipsBox = document.getElementById("chips");
const statusEl = document.getElementById("status");

function setStatus(msg){ statusEl.textContent = msg || ""; }
function addMsg(text, who="bot"){
  const div = document.createElement("div");
  div.className = "msg " + (who === "user" ? "user" : "bot");
  div.textContent = text;
  chat.appendChild(div);
  chat.scrollTop = chat.scrollHeight;
}
function setChips(options){
  chipsBox.innerHTML = "";
  (options || []).forEach(opt=>{
    const b = document.createElement("div");
    b.className = "chip";
    b.textContent = opt;
    b.onclick = ()=>{ input.value = opt; send(); };
    chipsBox.appendChild(b);
  });
}
function clean(s){ return String(s||"").trim(); }
function lower(s){ return clean(s).toLowerCase(); }
function upper(s){ return clean(s).toUpperCase(); }
function digitsOnly(s){ return String(s||"").replace(/[^\d]/g,""); }
function money(v){
  const n = Number(v);
  return Number.isFinite(n) ? "$" + n.toFixed(2) : "$0.00";
}
function safeToDate(v){
  if(!v) return null;
  if(typeof v?.toDate === "function") return v.toDate();
  if(typeof v?.seconds === "number") return new Date(v.seconds*1000);
  const d = new Date(v);
  return isNaN(d.getTime()) ? null : d;
}
function fmtDate(v){
  const d = safeToDate(v);
  return d ? d.toLocaleString() : "";
}
function normalizeStatus(s){
  const t = String(s||"new").toLowerCase().trim();
  if(["new","pending","unpaid","done","archived","cancelled","refunded","flagged"].includes(t)) return t;
  if(t === "completed") return "done";
  return t || "new";
}
function startOfToday(){ const d=new Date(); d.setHours(0,0,0,0); return d; }
function startOfWeek(){ const d=startOfToday(); const day=d.getDay(); d.setDate(d.getDate()-day); return d; }
function startOfMonth(){ const d=startOfToday(); d.setDate(1); return d; }

/* =========================
   MULTI-BUSINESS
========================= */
const BUSINESSES = "tt_businesses";

function rand5(){
  const n = crypto.getRandomValues(new Uint32Array(1))[0] % 100000;
  return String(n).padStart(5,"0");
}
async function makeUniqueBizCode5(){
  for(let i=0;i<60;i++){
    const code = rand5();
    const snap = await db.collection(BUSINESSES).doc(code).get();
    if(!snap.exists) return code;
  }
  return String(Math.floor(Math.random()*100000)).padStart(5,"0");
}
async function sha256Hex(text){
  const enc = new TextEncoder().encode(String(text));
  const buf = await crypto.subtle.digest("SHA-256", enc);
  return [...new Uint8Array(buf)].map(b=>b.toString(16).padStart(2,"0")).join("");
}
function newUserId(){
  return "u_" + crypto.getRandomValues(new Uint32Array(3)).join("").slice(0,14);
}

/* Session */
const session = {
  biz: "",
  userId: "",
  username: "",
  role: "",
  loggedIn: false
};
function requireLogin(){
  if(!session.loggedIn) throw new Error("Not logged in. Use: LOGIN <bizCode> <username> <password>");
}
function roleLevel(role){
  role = String(role||"").toLowerCase();
  if(role === "owner") return 3;
  if(role === "manager") return 2;
  return 1;
}
function requireRole(minRole){
  requireLogin();
  if(roleLevel(session.role) < roleLevel(minRole)){
    throw new Error(`Permission denied. Need ${minRole}+`);
  }
}

/* Scoped collections */
function bizDoc(){ requireLogin(); return db.collection(BUSINESSES).doc(session.biz); }
function usersCol(){ return bizDoc().collection("users"); }
function ordersCol(){ return bizDoc().collection("orders"); }
function skillsCol(){ return bizDoc().collection("skills"); }
function aliasesCol(){ return bizDoc().collection("aliases"); }
function logsCol(){ return bizDoc().collection("logs"); }

/* =========================
   Logging
========================= */
async function logAction(action, meta){
  try{
    if(!session.loggedIn) return;
    await logsCol().add({
      at: ts(),
      byUserId: session.userId,
      byUsername: session.username,
      byRole: session.role,
      action: String(action||""),
      meta: meta || {}
    });
  }catch{}
}

/* =========================
   Aliases (order nicknames)
========================= */
function normAlias(s){
  return String(s||"")
    .toLowerCase()
    .trim()
    .replace(/\s+/g," ")
    .replace(/[^\w\s-]/g,"");
}
function looksLikeId(tok){
  const t = String(tok||"").trim();
  if(!t) return false;
  if(t.length < 4) return false;
  if(t.includes(" ")) return false;
  return /[a-z0-9]/i.test(t);
}
async function setAlias(alias, orderId){
  const a = normAlias(alias);
  if(!a) throw new Error("Alias empty.");
  await aliasesCol().doc(a).set({ alias:a, orderId:String(orderId).trim(), updatedAt: ts() }, { merge:true });
}
async function getAlias(alias){
  const a = normAlias(alias);
  const snap = await aliasesCol().doc(a).get();
  return snap.exists ? snap.data() : null;
}
async function delAlias(alias){
  const a = normAlias(alias);
  await aliasesCol().doc(a).delete();
}
async function resolveOrderId(token){
  const t = String(token||"").trim();
  if(!t) return "";
  if(looksLikeId(t)) return t;
  const hit = await getAlias(t);
  return hit?.orderId || "";
}

/* =========================
   Skills (learned triggers)
========================= */
async function saveSkill(trigger, action){
  await skillsCol().add({
    trigger: normAlias(trigger),
    action: String(action||"").trim(),
    createdAt: ts()
  });
}
async function loadSkills(limit=900){
  const snap = await skillsCol().limit(limit).get();
  return snap.docs.map(d=>({ id:d.id, ...d.data() }));
}
async function forgetSkill(trigger){
  const trg = normAlias(trigger);
  const snap = await skillsCol().where("trigger","==",trg).limit(200).get();
  const batch = db.batch();
  snap.docs.forEach(d=>batch.delete(d.ref));
  await batch.commit();
}

/* =========================
   Orders cache
========================= */
const ORDER_FETCH_LIMIT = 900;
let orderCache = [];
let orderCacheAt = 0;
const TTL = 15000;

async function refreshOrders(){
  requireLogin();
  const snap = await ordersCol().limit(ORDER_FETCH_LIMIT).get();
  orderCache = snap.docs.map(d=>({ id:d.id, ...d.data() }));
  orderCacheAt = Date.now();
  return orderCache;
}
async function ensureOrdersFresh(){
  requireLogin();
  if(!orderCache.length || (Date.now() - orderCacheAt) > TTL) await refreshOrders();
  return orderCache;
}
function bustOrders(){ orderCacheAt = 0; }

function orderCreatedDate(r){ return safeToDate(r.createdAt) || new Date(0); }
function isToday(r){ return orderCreatedDate(r) >= startOfToday(); }
function isThisWeek(r){ return orderCreatedDate(r) >= startOfWeek(); }
function isThisMonth(r){ return orderCreatedDate(r) >= startOfMonth(); }
function orderTotal(r){
  const n = Number(r?.totals?.total);
  return Number.isFinite(n) ? n : 0;
}
function compactOrderLine(r){
  const o = r.order || {};
  return `â€¢ ${r.id} | ${normalizeStatus(r.status)} | ${o.name||""} | ${o.phone||""} | ${money(orderTotal(r))}`;
}
function formatOrderList(rows, title){
  if(!rows.length) return `${title}: none found.`;
  return [`${title} (showing ${rows.length}):`, ...rows.map(compactOrderLine)].join("\n");
}

/* =========================
   Priority / Next
========================= */
function priorityScore(r){
  const s = normalizeStatus(r.status);
  const rush = !!(r.order && r.order.rush);
  if(s === "unpaid" && rush) return 1;
  if(s === "unpaid") return 2;
  if(s === "pending" && rush) return 3;
  if(s === "pending") return 4;
  if(s === "new" && rush) return 5;
  if(s === "new") return 6;
  return 99;
}
function pickNext(rows){
  const unfinished = rows.filter(r=>!["done","archived","cancelled","refunded"].includes(normalizeStatus(r.status)));
  unfinished.sort((a,b)=>{
    const sa = priorityScore(a), sb = priorityScore(b);
    if(sa !== sb) return sa - sb;
    return orderCreatedDate(a).getTime() - orderCreatedDate(b).getTime();
  });
  return unfinished[0] || null;
}

/* =========================
   Safe delete
========================= */
const pendingDeletes = new Map();
function armDelete(id){ pendingDeletes.set(id, Date.now()); }
function canConfirmDelete(id){
  const t = pendingDeletes.get(id);
  if(!t) return false;
  if(Date.now() - t > 60000){ pendingDeletes.delete(id); return false; }
  return true;
}

/* =========================
   Order details (SHOWALL)
   Shows EVERYTHING including extras, rules, checklist, history
========================= */
function summarizeItems(items){
  if(!Array.isArray(items) || !items.length) return "(none)";

  const pickExtras = (it)=>{
    const extras = [];
    for(const [k,v] of Object.entries(it || {})){
      if(v === undefined || v === null) continue;
      if(v === "" ) continue;
      if(Array.isArray(v) && v.length === 0) continue;
      if(typeof v === "boolean" && v === false) continue;
      if(["itemType","weave","inches","fit","colors","patternStyle"].includes(k)) continue;
      extras.push(`${k}: ${Array.isArray(v) ? v.join(", ") : String(v)}`);
    }
    return extras;
  };

  return items.map((it, i)=>{
    const colors = Array.isArray(it.colors) ? it.colors.join(" / ") : "";
    const extras = pickExtras(it);
    return [
      `${i+1}) ${it.itemType || "(item)"}`,
      `   â€¢ weave: ${it.weave || ""}`,
      `   â€¢ size: ${it.inches || ""}"`,
      `   â€¢ fit: ${it.fit || ""}`,
      `   â€¢ colors: ${colors || "(none)"}`,
      `   â€¢ pattern: ${it.patternStyle || "(none)"}`,
      extras.length ? `   â€¢ extras:\n     - ${extras.join("\n     - ")}` : `   â€¢ extras: (none)`
    ].join("\n");
  }).join("\n\n");
}

function orderCard(id, data){
  const o = data?.order || {};
  const totals = data?.totals || {};
  const items = data?.items || [];

  const knownTop = new Set([
    "status","createdAt","order","items","totals",
    "assignedTo","assignedAt","assignedBy","assignedNote",
    "adminNote","tracking","flagged","problemNote",
    "paidAt","shippedAt","doneAt","doneBy",
    "claimedBy","claimedAt","rules","checklist","history",
    "adminNoteBy","adminNoteAt"
  ]);

  const extraTop = [];
  for(const [k,v] of Object.entries(data || {})){
    if(knownTop.has(k)) continue;
    if(v === undefined || v === null) continue;
    if(v === "" ) continue;
    if(Array.isArray(v) && v.length === 0) continue;
    if(typeof v === "boolean" && v === false) continue;
    extraTop.push(`${k}: ${typeof v?.toDate === "function" ? fmtDate(v) : (Array.isArray(v) ? JSON.stringify(v) : String(v))}`);
  }

  const orderLines = [];
  for(const [k,v] of Object.entries(o || {})){
    if(v === undefined || v === null) continue;
    if(v === "" ) continue;
    if(typeof v === "boolean" && v === false) continue;
    orderLines.push(`  â€¢ ${k}: ${String(v)}`);
  }

  const totalsLines = [];
  for(const [k,v] of Object.entries(totals || {})){
    if(v === undefined || v === null) continue;
    totalsLines.push(`  â€¢ ${k}: ${typeof v === "number" ? money(v) : String(v)}`);
  }

  const rulesTxt = (Array.isArray(data?.rules) && data.rules.length)
    ? ("â€¢ " + data.rules.map(r=>String(r)).join("\nâ€¢ "))
    : "(none)";

  const checklistTxt = (Array.isArray(data?.checklist) && data.checklist.length)
    ? data.checklist.map((s,i)=>{
        const done = s.done ? "âœ…" : "â¬œ";
        const who = s.doneBy ? ` (by ${s.doneBy})` : "";
        const when = s.doneAt ? ` @ ${fmtDate(s.doneAt)}` : "";
        return `${i+1}) ${done} ${s.text || ""}${who}${when}`;
      }).join("\n")
    : "(none)";

  const historyTxt = (Array.isArray(data?.history) && data.history.length)
    ? data.history.slice(0, 18).map(h=>{
        const at = fmtDate(h.at) || h.atIso || "";
        const by = h.by || "";
        const act = h.action || "";
        const extra = h.note ? ` | ${h.note}` : "";
        return `â€¢ ${act} by ${by} @ ${at}${extra}`;
      }).join("\n")
    : "(none)";

  return [
    `ORDER FULL DETAILS`,
    `Business: ${session.biz}`,
    `Order ID: ${id}`,
    `Status: ${normalizeStatus(data?.status)}`,
    `Created: ${fmtDate(data?.createdAt)}`,
    ``,
    `Customer / Shipping (order object):`,
    orderLines.length ? orderLines.join("\n") : "  (none)",
    ``,
    `Admin + Assignment:`,
    `  â€¢ assignedTo: ${data?.assignedTo || ""}`,
    `  â€¢ assignedBy: ${data?.assignedBy || ""}`,
    `  â€¢ assignedAt: ${fmtDate(data?.assignedAt)}`,
    `  â€¢ assignedNote: ${data?.assignedNote || ""}`,
    `  â€¢ claimedBy: ${data?.claimedBy || ""}`,
    `  â€¢ claimedAt: ${fmtDate(data?.claimedAt)}`,
    `  â€¢ adminNote: ${data?.adminNote || ""}`,
    `  â€¢ adminNoteBy: ${data?.adminNoteBy || ""}`,
    `  â€¢ adminNoteAt: ${fmtDate(data?.adminNoteAt)}`,
    `  â€¢ tracking: ${data?.tracking || ""}`,
    `  â€¢ flagged: ${data?.flagged ? "yes" : "no"}`,
    `  â€¢ problemNote: ${data?.problemNote || ""}`,
    `  â€¢ paidAt: ${fmtDate(data?.paidAt)}`,
    `  â€¢ shippedAt: ${fmtDate(data?.shippedAt)}`,
    `  â€¢ doneAt: ${fmtDate(data?.doneAt)}`,
    `  â€¢ doneBy: ${data?.doneBy || ""}`,
    ``,
    `Totals:`,
    totalsLines.length ? totalsLines.join("\n") : "  (none)",
    ``,
    `Items:`,
    summarizeItems(items),
    ``,
    `Rules:`,
    rulesTxt,
    ``,
    `Checklist:`,
    checklistTxt,
    ``,
    `History (last 18):`,
    historyTxt,
    ``,
    extraTop.length ? `EXTRA FIELDS:\n${extraTop.map(x=>"â€¢ "+x).join("\n")}` : "EXTRA FIELDS: (none)"
  ].join("\n");
}

/* =========================
   History + order patch helper
========================= */
function nowIso(){ return new Date().toISOString(); }
function pushHistory(existing, entry){
  const arr = Array.isArray(existing) ? existing.slice(0, 80) : [];
  arr.unshift(entry);
  return arr.slice(0, 80);
}
async function updateOrderWithHistory(orderId, patch, action, extraMeta={}){
  const ref = ordersCol().doc(orderId);
  const snap = await ref.get();
  if(!snap.exists) throw new Error("Order not found: " + orderId);

  const data = snap.data() || {};
  const history = pushHistory(data.history, {
    at: ts(),
    atIso: nowIso(),
    by: session.username,
    role: session.role,
    action,
    ...extraMeta
  });

  await ref.set({ ...patch, history }, { merge:true });
  bustOrders();
}

/* =========================
   Natural language -> command (simple)
========================= */
function interpretNatural(text){
  const t = clean(text);
  const L = t.toLowerCase();
  const U = t.toUpperCase();

  if(U === "?") return "HELP";
  if(U.startsWith("LOGIN ") || U.startsWith("NEWBIZ ") || U.startsWith("LOGOUT")) return t;
  if(U === "WHOAMI") return "WHOAMI";

  if(L.includes("monthly") && (L.includes("gross") || L.includes("revenue"))) return "REVENUE MONTH";
  if(L.includes("weekly") && (L.includes("gross") || L.includes("revenue"))) return "REVENUE WEEK";
  if(L.includes("today") && (L.includes("gross") || L.includes("revenue"))) return "REVENUE TODAY";

  if(L.includes("next")) return "NEXT";
  if(L.includes("unfinished")) return "UNFINISHED";
  if(L.includes("unpaid")) return "UNPAID";
  if(L.includes("priority")) return "PRIORITY";

  if(L.includes("mark") && (L.includes("done") || L.includes("complete"))){
    const rest = L.replace("mark","").replace("as","").replace("done","").replace("complete","").replace("completed","").trim();
    return "DONE " + (rest || "");
  }

  const digs = digitsOnly(t);
  if(digs.length >= 7) return "BYPHONE " + digs;

  return t;
}

/* =========================
   HELP
========================= */
function helpText(){
  return [
    "MULTI-BUSINESS ADMIN (FULL)",
    "",
    "Create business (auto 5-digit code):",
    "  NEWBIZ <businessName...> <ownerPassword>",
    "  (creates owner username = owner)",
    "",
    "Login / session:",
    "  LOGIN <bizCode5> <username> <password>",
    "  WHOAMI | LOGOUT",
    "",
    "Users (Manager/Owner controls):",
    "  ADDCO <username> <password> staff|manager   (manager+)",
    "  LISTUSERS (manager+)",
    "  RENAMEUSER <old> <new> (manager+)",
    "  SETROLE <username> staff|manager (owner only)",
    "  DISABLEUSER <username> (manager+)",
    "  ENABLEUSER <username> (manager+)",
    "",
    "Orders (scoped to business):",
    "  NEXT | PRIORITY | UNFINISHED | UNPAID | TODAY | WEEK | MONTH",
    "  SHOWALL <idOrNickname>",
    "  NICK <idOrNickname> <nickname> | ALIASES | UNNICK <nickname>",
    "  CLAIM <idOrNick> | MYQUEUE | UNCLAIM <idOrNick> (manager+)",
    "  NOTE <idOrNick> <text...>",
    "",
    "Admin assigns work (manager+):",
    "  ASSIGN <idOrNick> <username> | <note...>",
    "  ASSIGNNOTE <idOrNick> <note...>",
    "  UNASSIGN <idOrNick>",
    "  MYASSIGNED (shows orders assignedTo you)",
    "",
    "Rules + checklist:",
    "  RULESADD <idOrNick> <rule text> (manager+)",
    "  RULESCLEAR <idOrNick> (manager+)",
    "  CHECKADD <idOrNick> <step text> (manager+)",
    "  CHECKLIST <idOrNick>",
    "  CHECKDONE <idOrNick> <step#>",
    "  CHECKUNDO <idOrNick> <step#> (staff can undo own; manager+ can undo any)",
    "",
    "Status:",
    "  DONE <idOrNick>   (sets doneAt + doneBy)",
    "  PAID <idOrNick>   (sets paidAt)",
    "  SHIPPED <idOrNick> (sets shippedAt)",
    "",
    "Safety:",
    "  DELETE <idOrNick> (manager+, arms 60s)",
    "  DELETE <idOrNick> CONFIRM",
    "",
    "Money:",
    "  REVENUE TODAY|WEEK|MONTH",
    "  TOTALS TODAY|WEEK|MONTH",
    "",
    "Learn triggers (saved in Firestore):",
    "  LEARN | LISTSKILLS | FORGET <trigger> (manager+)",
  ].join("\n");
}

/* =========================
   Main state
========================= */
const state = {
  lastOrderId: "",
  learnMode: null,     // null | "awaitTrigger" | "awaitAction"
  learnTrigger: ""
};

/* =========================
   COMMAND HANDLER
========================= */
async function handleCommand(raw){
  const text = clean(raw);
  const U = upper(text);
  if(!text) return;

  // Learn capture
  if(state.learnMode === "awaitTrigger"){
    requireLogin();
    state.learnTrigger = clean(raw);
    state.learnMode = "awaitAction";
    addMsg(`Trigger saved:\n"${normAlias(state.learnTrigger)}"\n\nNow type the ACTION command to run.`, "bot");
    setChips(["CANCEL LEARN","HELP"]);
    return;
  }
  if(state.learnMode === "awaitAction"){
    requireLogin();
    const action = clean(raw);
    await saveSkill(state.learnTrigger, action);
    await logAction("learn_skill", { trigger: normAlias(state.learnTrigger), action });
    addMsg(`âœ… Learned (saved in Firestore):\n"${normAlias(state.learnTrigger)}" â†’ ${action}`, "bot");
    state.learnMode = null;
    state.learnTrigger = "";
    setChips(["LISTSKILLS","HELP","NEXT"]);
    return;
  }

  // HELP works logged out
  if(U === "HELP"){
    setStatus("");
    addMsg(helpText(), "bot");
    setChips(["NEWBIZ TacticsTreats mypass","LOGIN 00000 owner pass","WHOAMI","NEXT","UNPAID","UNFINISHED"]);
    return;
  }

  // NEWBIZ <name...> <ownerPassword>
  if(U.startsWith("NEWBIZ ")){
    const parts = text.split(/\s+/);
    if(parts.length < 3){
      addMsg("Usage: NEWBIZ <businessName...> <ownerPassword>", "bot");
      return;
    }
    const ownerPassword = parts.pop();
    const businessName = parts.slice(1).join(" ").trim();

    setStatus("Workingâ€¦");
    const biz = await makeUniqueBizCode5();
    const ownerId = newUserId();
    const passHash = await sha256Hex(ownerPassword);

    await db.collection(BUSINESSES).doc(biz).set({
      businessCode: biz,
      businessName,
      createdAt: ts(),
      updatedAt: ts(),
      codeLocked: true
    }, { merge:true });

    await db.collection(BUSINESSES).doc(biz).collection("users").doc(ownerId).set({
      userId: ownerId,
      username: "owner",
      passHash,
      role: "owner",
      active: true,
      createdAt: ts(),
      updatedAt: ts()
    }, { merge:true });

    session.biz = biz;
    session.userId = ownerId;
    session.username = "owner";
    session.role = "owner";
    session.loggedIn = true;

    bustOrders();
    setStatus("");
    addMsg(`âœ… Business created!\nBusiness code (never changes): ${biz}\nLogged in as: owner`, "bot");
    setChips(["WHOAMI","LISTUSERS","ADDCO jen pass123 staff","NEXT","HELP"]);
    await logAction("create_business", { biz, businessName });
    return;
  }

  // LOGIN <bizCode5> <username> <password>
  if(U.startsWith("LOGIN ")){
    const parts = text.split(/\s+/);
    const biz = (parts[1]||"").trim();
    const username = (parts[2]||"").trim().toLowerCase();
    const password = parts.slice(3).join(" ");

    if(!/^\d{5}$/.test(biz)){
      addMsg("Business code must be 5 digits. Example: LOGIN 48392 owner pass", "bot");
      return;
    }
    if(!username || !password){
      addMsg("Usage: LOGIN <bizCode5> <username> <password>", "bot");
      return;
    }

    setStatus("Workingâ€¦");
    const q = await db.collection(BUSINESSES).doc(biz).collection("users")
      .where("username","==",username).limit(1).get();

    if(q.empty){
      setStatus("");
      addMsg("Login failed.", "bot");
      return;
    }

    const doc = q.docs[0];
    const user = doc.data();
    if(user.active === false){
      setStatus("");
      addMsg("Login failed (disabled).", "bot");
      return;
    }

    const entered = await sha256Hex(password);
    if(String(user.passHash||"") !== entered){
      setStatus("");
      addMsg("Login failed (wrong password).", "bot");
      return;
    }

    session.biz = biz;
    session.userId = user.userId || doc.id;
    session.username = user.username || username;
    session.role = user.role || "staff";
    session.loggedIn = true;

    bustOrders();

    setStatus("");
    addMsg(`âœ… Logged in to ${biz} as ${session.username} (${session.role})`, "bot");
    setChips(["WHOAMI","NEXT","UNPAID","UNFINISHED","HELP"]);
    await logAction("login", {});
    return;
  }

  if(U === "LOGOUT"){
    if(session.loggedIn) await logAction("logout", {});
    session.biz=""; session.userId=""; session.username=""; session.role=""; session.loggedIn=false;
    state.lastOrderId = "";
    bustOrders();
    setStatus("");
    addMsg("âœ… Logged out.", "bot");
    setChips(["HELP","NEWBIZ MyBiz mypass","LOGIN 00000 owner pass"]);
    return;
  }

  if(U === "WHOAMI"){
    requireLogin();
    addMsg(`Business: ${session.biz}\nUser: ${session.username}\nRole: ${session.role}`, "bot");
    return;
  }

  /* Everything below needs login */
  requireLogin();

  // Learned triggers (before normal commands)
  if(U !== "LEARN" && U !== "LISTSKILLS" && !U.startsWith("FORGET ") && U !== "CANCEL LEARN"){
    try{
      const skills = await loadSkills(900);
      const L = lower(text);
      const scored = skills
        .map(s=>{
          const trig = String(s.trigger||"").toLowerCase().trim();
          if(!trig) return null;
          let score = 0;
          if(L === trig) score = 300;
          else if(L.startsWith(trig)) score = 200;
          else if(L.includes(trig)) score = 100;
          if(!score) return null;
          score += Math.min(50, trig.length);
          return { s, score };
        })
        .filter(Boolean)
        .sort((a,b)=>b.score - a.score);
      if(scored.length){
        await handleCommand(String(scored[0].s.action||""));
        return;
      }
    }catch{}
  }

  // LEARN / skills
  if(U === "LEARN"){
    state.learnMode = "awaitTrigger";
    state.learnTrigger = "";
    addMsg('What phrase do you want me to learn? (example: "monthly gross")', "bot");
    setChips(["CANCEL LEARN","HELP"]);
    return;
  }
  if(U === "CANCEL LEARN"){
    state.learnMode = null;
    state.learnTrigger = "";
    addMsg("Learn cancelled.", "bot");
    setChips(["HELP","NEXT","UNPAID"]);
    return;
  }
  if(U === "LISTSKILLS"){
    const skills = await loadSkills(200);
    if(!skills.length){ addMsg("No learned commands yet. Type LEARN.", "bot"); return; }
    addMsg("Learned triggers:\n" + skills.map(s=>`â€¢ "${s.trigger}" â†’ ${s.action}`).join("\n"), "bot");
    setChips(["LEARN","FORGET monthly gross","HELP"]);
    return;
  }
  if(U.startsWith("FORGET ")){
    requireRole("manager");
    const trg = clean(text.slice(7));
    if(!trg){ addMsg("Usage: FORGET <trigger>", "bot"); return; }
    await forgetSkill(trg);
    await logAction("forget_skill", { trigger: normAlias(trg) });
    addMsg(`ðŸ§½ Forgot trigger: "${normAlias(trg)}"`, "bot");
    return;
  }

  // Users: add coworker (manager+)
  if(U.startsWith("ADDCO ")){
    requireRole("manager");
    const parts = text.split(/\s+/);
    const username = (parts[1]||"").toLowerCase().trim();
    const password = parts[2] || "";
    const role = (parts[3]||"staff").toLowerCase();

    if(!username || !password){
      addMsg("Usage: ADDCO <username> <password> staff|manager", "bot");
      return;
    }
    if(!/^[a-z0-9_]{3,20}$/.test(username)){
      addMsg("Username must be 3-20 chars: letters, numbers, underscore.", "bot");
      return;
    }
    if(!["staff","manager"].includes(role)){
      addMsg("Role must be staff or manager (owner is only created by system).", "bot");
      return;
    }

    const taken = await usersCol().where("username","==",username).limit(1).get();
    if(!taken.empty){
      addMsg("That username is already taken.", "bot");
      return;
    }

    const userId = newUserId();
    const passHash = await sha256Hex(password);
    await usersCol().doc(userId).set({
      userId,
      username,
      passHash,
      role,
      active:true,
      createdAt: ts(),
      updatedAt: ts()
    }, { merge:true });

    await logAction("add_user", { username, role, userId });
    addMsg(`âœ… Added user: ${username} (${role})`, "bot");
    setChips(["LISTUSERS","HELP"]);
    return;
  }

  if(U === "LISTUSERS"){
    requireRole("manager");
    const snap = await usersCol().limit(200).get();
    const users = snap.docs.map(d=>({ id:d.id, ...d.data() }))
      .sort((a,b)=>String(a.username||"").localeCompare(String(b.username||"")));
    if(!users.length){ addMsg("No users.", "bot"); return; }
    addMsg("Users:\n" + users.map(u=>`â€¢ ${u.username} | ${u.role} | ${u.active===false?"inactive":"active"}`).join("\n"), "bot");
    setChips(["RENAMEUSER jen jen2","DISABLEUSER jen","ENABLEUSER jen","HELP"]);
    return;
  }

  if(U.startsWith("RENAMEUSER ")){
    requireRole("manager");
    const parts = text.split(/\s+/);
    const oldName = (parts[1]||"").toLowerCase().trim();
    const newName = (parts[2]||"").toLowerCase().trim();

    if(!oldName || !newName){
      addMsg("Usage: RENAMEUSER <oldUsername> <newUsername>", "bot");
      return;
    }
    if(!/^[a-z0-9_]{3,20}$/.test(newName)){
      addMsg("New username must be 3-20 chars: letters, numbers, underscore.", "bot");
      return;
    }

    const qOld = await usersCol().where("username","==",oldName).limit(1).get();
    if(qOld.empty){ addMsg("User not found: " + oldName, "bot"); return; }
    const targetRef = qOld.docs[0].ref;
    const target = qOld.docs[0].data();

    if(String(target.role) === "owner" && session.role !== "owner"){
      addMsg("Only owner can rename the owner account.", "bot");
      return;
    }

    const qNew = await usersCol().where("username","==",newName).limit(1).get();
    if(!qNew.empty){ addMsg("That username is already taken.", "bot"); return; }

    await targetRef.set({ username:newName, updatedAt: ts() }, { merge:true });
    await logAction("rename_user", { from: oldName, to: newName });

    addMsg(`âœ… Renamed "${oldName}" â†’ "${newName}"`, "bot");
    return;
  }

  if(U.startsWith("SETROLE ")){
    requireRole("owner");
    const parts = text.split(/\s+/);
    const username = (parts[1]||"").toLowerCase().trim();
    const newRole = (parts[2]||"").toLowerCase().trim();

    if(!username || !["staff","manager"].includes(newRole)){
      addMsg("Usage: SETROLE <username> staff|manager", "bot");
      return;
    }

    const q = await usersCol().where("username","==",username).limit(1).get();
    if(q.empty){ addMsg("User not found.", "bot"); return; }
    const doc = q.docs[0];
    const user = doc.data();

    if(String(user.role) === "owner"){
      addMsg("Owner role cannot be changed.", "bot");
      return;
    }

    await doc.ref.set({ role:newRole, updatedAt: ts() }, { merge:true });
    await logAction("set_role", { username, newRole });

    addMsg(`âœ… Role updated: ${username} â†’ ${newRole}`, "bot");
    return;
  }

  if(U.startsWith("DISABLEUSER ")){
    requireRole("manager");
    const username = clean(text.slice(12)).toLowerCase();

    if(!username){ addMsg("Usage: DISABLEUSER <username>", "bot"); return; }

    const q = await usersCol().where("username","==",username).limit(1).get();
    if(q.empty){ addMsg("User not found.", "bot"); return; }
    const doc = q.docs[0];
    const user = doc.data();

    if(String(user.role) === "owner"){
      addMsg("Owner cannot be disabled.", "bot");
      return;
    }

    await doc.ref.set({ active:false, updatedAt: ts() }, { merge:true });
    await logAction("disable_user", { username });

    addMsg(`âœ… Disabled: ${username}`, "bot");
    return;
  }

  if(U.startsWith("ENABLEUSER ")){
    requireRole("manager");
    const username = clean(text.slice(11)).toLowerCase();

    if(!username){ addMsg("Usage: ENABLEUSER <username>", "bot"); return; }

    const q = await usersCol().where("username","==",username).limit(1).get();
    if(q.empty){ addMsg("User not found.", "bot"); return; }
    const doc = q.docs[0];

    await doc.ref.set({ active:true, updatedAt: ts() }, { merge:true });
    await logAction("enable_user", { username });

    addMsg(`âœ… Enabled: ${username}`, "bot");
    return;
  }

  // Nicknames (Aliases)
  if(U.startsWith("NICK ")){
    const rest = text.slice(5);
    const parts = rest.split(/\s+/);
    const tok = parts[0] || state.lastOrderId;
    const aliasText = parts.slice(1).join(" ");

    const id = await resolveOrderId(tok || state.lastOrderId);
    if(!id){ addMsg("NICK needs an order id/nickname (use NEXT/SHOWALL first).", "bot"); return; }
    if(!clean(aliasText)){ addMsg("Usage: NICK <idOrNickname> <newNickname>", "bot"); return; }

    await setAlias(aliasText, id);
    await logAction("set_alias", { alias: normAlias(aliasText), orderId: id });
    addMsg(`âœ… Nickname saved:\n"${normAlias(aliasText)}" â†’ ${id}`, "bot");
    setChips([`SHOWALL ${normAlias(aliasText)}`, `DONE ${normAlias(aliasText)}`, `ASSIGN ${normAlias(aliasText)} `]);
    return;
  }

  if(U === "ALIASES"){
    const snap = await aliasesCol().limit(200).get();
    const a = snap.docs.map(d=>d.data()).sort((x,y)=>String(x.alias||"").localeCompare(String(y.alias||"")));
    if(!a.length){ addMsg("No nicknames yet. Use NICK <id> <name>", "bot"); return; }
    addMsg("Nicknames:\n" + a.map(x=>`â€¢ "${x.alias}" â†’ ${x.orderId}`).join("\n"), "bot");
    return;
  }

  if(U.startsWith("UNNICK ")){
    const a = clean(text.slice(7));
    if(!a){ addMsg("Usage: UNNICK <nickname>", "bot"); return; }
    await delAlias(a);
    await logAction("del_alias", { alias: normAlias(a) });
    addMsg(`ðŸ§½ Removed nickname: "${normAlias(a)}"`, "bot");
    return;
  }

  // Money
  if(U.startsWith("REVENUE ")){
    const range = upper(text.split(/\s+/)[1]||"MONTH");
    const rows = await ensureOrdersFresh();
    const pred = (range==="TODAY") ? isToday : (range==="WEEK" ? isThisWeek : isThisMonth);
    const inRange = rows.filter(pred);
    const done = inRange.filter(r=>normalizeStatus(r.status)==="done");
    const revenue = done.reduce((s,r)=>s+orderTotal(r),0);
    addMsg(`REVENUE ${range}\n${money(revenue)} (done orders only)`, "bot");
    return;
  }

  if(U.startsWith("TOTALS ")){
    const range = upper(text.split(/\s+/)[1]||"MONTH");
    const rows = await ensureOrdersFresh();
    const pred = (range==="TODAY") ? isToday : (range==="WEEK" ? isThisWeek : isThisMonth);
    const inRange = rows.filter(pred);
    const done = inRange.filter(r=>normalizeStatus(r.status)==="done");
    const revenue = done.reduce((s,r)=>s+orderTotal(r),0);
    addMsg(`TOTALS ${range}\nOrders: ${inRange.length}\nDone: ${done.length}\nRevenue (done): ${money(revenue)}`, "bot");
    return;
  }

  // Lists
  const cmd0 = upper(text.split(/\s+/)[0]||"");
  const listCmds = ["UNFINISHED","NEW","PENDING","UNPAID","DONE","TODAY","WEEK","MONTH","PRIORITY"];
  if(listCmds.includes(cmd0)){
    const rows = await ensureOrdersFresh();
    let out = rows.slice();

    if(cmd0 === "UNFINISHED") out = out.filter(r=>!["done","archived","cancelled","refunded"].includes(normalizeStatus(r.status)));
    if(cmd0 === "NEW") out = out.filter(r=>normalizeStatus(r.status)==="new");
    if(cmd0 === "PENDING") out = out.filter(r=>normalizeStatus(r.status)==="pending");
    if(cmd0 === "UNPAID") out = out.filter(r=>normalizeStatus(r.status)==="unpaid");
    if(cmd0 === "DONE") out = out.filter(r=>normalizeStatus(r.status)==="done");
    if(cmd0 === "TODAY") out = out.filter(isToday);
    if(cmd0 === "WEEK") out = out.filter(isThisWeek);
    if(cmd0 === "MONTH") out = out.filter(isThisMonth);

    if(cmd0 === "PRIORITY"){
      out = out.filter(r=>!["done","archived","cancelled","refunded"].includes(normalizeStatus(r.status)));
      out.sort((a,b)=>{
        const sa = priorityScore(a), sb = priorityScore(b);
        if(sa !== sb) return sa - sb;
        return orderCreatedDate(a).getTime() - orderCreatedDate(b).getTime();
      });
    }else{
      out.sort((a,b)=>orderCreatedDate(b).getTime() - orderCreatedDate(a).getTime());
    }

    out = out.slice(0, 60);
    addMsg(formatOrderList(out, cmd0), "bot");
    setChips(["NEXT", out[0]?.id ? `SHOWALL ${out[0].id}` : "SHOWALL ", "UNPAID","UNFINISHED","HELP"]);
    return;
  }

  // NEXT
  if(U === "NEXT"){
    const rows = await ensureOrdersFresh();
    const next = pickNext(rows);
    if(!next){ addMsg("NEXT: none found ðŸŽ‰", "bot"); return; }
    state.lastOrderId = next.id;
    addMsg(orderCard(next.id, next), "bot");
    setChips([
      `NICK ${next.id} `,
      `ASSIGN ${next.id} `,
      `CHECKLIST ${next.id}`,
      `DONE ${next.id}`,
      `SHIPPED ${next.id}`,
      `PAID ${next.id}`,
      `DELETE ${next.id}`,
      `SHOWALL ${next.id}`,
      "MYASSIGNED",
      "MYQUEUE"
    ]);
    return;
  }

  // SHOWALL
  if(U.startsWith("SHOWALL ")){
    const token = clean(text.slice(8)) || state.lastOrderId;
    const id = await resolveOrderId(token);
    if(!id){ addMsg("SHOWALL needs an id or nickname.", "bot"); return; }
    const snap = await ordersCol().doc(id).get();
    if(!snap.exists){ addMsg(`Not found: ${id}`, "bot"); return; }
    state.lastOrderId = id;
    addMsg(orderCard(id, snap.data()), "bot");
    setChips([`NICK ${id} `,`ASSIGN ${token} `,`CHECKLIST ${token}`,`DONE ${token}`,`SHIPPED ${token}`,`PAID ${token}`,`DELETE ${token}`,"MYASSIGNED","NEXT"]);
    return;
  }

  // CLAIM / MYQUEUE / UNCLAIM
  if(U.startsWith("CLAIM ")){
    requireRole("staff");
    const token = clean(text.slice(6)) || state.lastOrderId;
    const id = await resolveOrderId(token);
    if(!id){ addMsg("CLAIM needs an id/nickname.", "bot"); return; }

    await updateOrderWithHistory(id, { claimedBy: session.username, claimedAt: ts() }, "CLAIM", {});
    await logAction("claim_order", { orderId:id });

    addMsg(`âœ… Claimed: ${id}`, "bot");
    return;
  }

  if(U === "MYQUEUE"){
    requireRole("staff");
    const rows = await ensureOrdersFresh();
    const mine = rows
      .filter(r=>String(r.claimedBy||"").toLowerCase() === session.username.toLowerCase())
      .sort((a,b)=>orderCreatedDate(b)-orderCreatedDate(a))
      .slice(0,80);
    addMsg(formatOrderList(mine, "MYQUEUE"), "bot");
    return;
  }

  if(U.startsWith("UNCLAIM ")){
    requireRole("manager");
    const token = clean(text.slice(8)) || state.lastOrderId;
    const id = await resolveOrderId(token);
    if(!id){ addMsg("UNCLAIM needs an id/nickname.", "bot"); return; }

    await updateOrderWithHistory(id, { claimedBy: "", claimedAt: null }, "UNCLAIM", {});
    await logAction("unclaim_order", { orderId:id });

    addMsg(`âœ… Unclaimed: ${id}`, "bot");
    return;
  }

  // NOTE <idOrNick> <text...>
  if(U.startsWith("NOTE ")){
    requireRole("staff");
    const rest = text.slice(5);
    const parts = rest.split(/\s+/);
    const token = parts[0] || state.lastOrderId;
    const note = parts.slice(1).join(" ");

    const id = await resolveOrderId(token);
    if(!id || !note){
      addMsg("Usage: NOTE <idOrNick> <text...>", "bot");
      return;
    }

    await updateOrderWithHistory(
      id,
      { adminNote: note, adminNoteBy: session.username, adminNoteAt: ts() },
      "NOTE",
      { note }
    );
    await logAction("note_order", { orderId:id });

    addMsg(`âœ… Note saved on ${id}`, "bot");
    return;
  }

  /* =========================================================
     ASSIGNMENT + NOTES (Manager+)
     ASSIGN <idOrNick> <username> | <note...>
     ASSIGNNOTE <idOrNick> <note...>
     UNASSIGN <idOrNick>
     MYASSIGNED (staff+)
  ========================================================= */
  if(U.startsWith("ASSIGN ")){
    requireRole("manager");

    const rawRest = text.slice(7).trim();
    const pipeIdx = rawRest.indexOf("|");
    const left = pipeIdx === -1 ? rawRest : rawRest.slice(0, pipeIdx).trim();
    const note = pipeIdx === -1 ? "" : rawRest.slice(pipeIdx+1).trim();

    const bits = left.split(/\s+/);
    const token = bits[0] || state.lastOrderId;
    const username = (bits[1] || "").toLowerCase().trim();

    if(!token || !username){
      addMsg("Usage: ASSIGN <idOrNick> <username> | <note...>", "bot");
      return;
    }

    // user exists + active
    const uq = await usersCol().where("username","==",username).limit(1).get();
    if(uq.empty){ addMsg("User not found: " + username, "bot"); return; }
    const u = uq.docs[0].data();
    if(u.active === false){ addMsg("User is disabled: " + username, "bot"); return; }

    const id = await resolveOrderId(token);
    if(!id){ addMsg("Order not found. Use SHOWALL / NEXT first.", "bot"); return; }

    await updateOrderWithHistory(
      id,
      {
        assignedTo: username,
        assignedAt: ts(),
        assignedBy: session.username,
        assignedNote: note || ""
      },
      "ASSIGN",
      { assignedTo: username, note: note || "" }
    );
    await logAction("assign_order", { orderId:id, assignedTo: username });

    addMsg(`âœ… Assigned ${id} â†’ ${username}\nNote: ${note || "(none)"}`, "bot");
    setChips([`SHOWALL ${id}`, `MYASSIGNED`, `UNASSIGN ${id}`, `ASSIGNNOTE ${id} `, `CHECKLIST ${id}`, "NEXT"]);
    return;
  }

  if(U.startsWith("ASSIGNNOTE ")){
    requireRole("manager");
    const rest = text.slice(11).trim();
    const parts = rest.split(/\s+/);
    const token = parts[0] || state.lastOrderId;
    const note = rest.slice((parts[0]||"").length).trim();

    const id = await resolveOrderId(token);
    if(!id || !note){
      addMsg("Usage: ASSIGNNOTE <idOrNick> <note...>", "bot");
      return;
    }

    await updateOrderWithHistory(id, { assignedNote: note }, "ASSIGNNOTE", { note });
    await logAction("assign_note", { orderId:id });

    addMsg(`âœ… Assigned note updated for ${id}`, "bot");
    setChips([`SHOWALL ${id}`, `CHECKLIST ${id}`, "NEXT"]);
    return;
  }

  if(U.startsWith("UNASSIGN ")){
    requireRole("manager");
    const token = clean(text.slice(9)) || state.lastOrderId;
    const id = await resolveOrderId(token);
    if(!id){ addMsg("Usage: UNASSIGN <idOrNick>", "bot"); return; }

    await updateOrderWithHistory(id, { assignedTo: "", assignedAt: null, assignedBy: "", assignedNote: "" }, "UNASSIGN");
    await logAction("unassign_order", { orderId:id });

    addMsg(`âœ… Unassigned order ${id}`, "bot");
    setChips([`SHOWALL ${id}`, "NEXT", "HELP"]);
    return;
  }

  if(U === "MYASSIGNED"){
    requireRole("staff");
    const rows = await ensureOrdersFresh();
    const mine = rows
      .filter(r => String(r.assignedTo||"").toLowerCase() === session.username.toLowerCase())
      .sort((a,b)=>orderCreatedDate(b) - orderCreatedDate(a))
      .slice(0, 120);

    addMsg(formatOrderList(mine, "MYASSIGNED"), "bot");
    setChips(["NEXT","MYQUEUE","UNFINISHED","HELP"]);
    return;
  }

  /* =========================================================
     RULES (Manager+)
     RULESADD <idOrNick> <rule text>
     RULESCLEAR <idOrNick>
  ========================================================= */
  if(U.startsWith("RULESADD ")){
    requireRole("manager");

    const rest = text.slice(9).trim();
    const parts = rest.split(/\s+/);
    const token = parts[0] || state.lastOrderId;
    const ruleText = rest.slice((parts[0]||"").length).trim();

    const id = await resolveOrderId(token);
    if(!id || !ruleText){
      addMsg("Usage: RULESADD <idOrNick> <rule text>", "bot");
      return;
    }

    const ref = ordersCol().doc(id);
    const snap = await ref.get();
    if(!snap.exists){ addMsg("Order not found.", "bot"); return; }
    const data = snap.data() || {};
    const rules = Array.isArray(data.rules) ? data.rules.slice(0, 30) : [];
    rules.push(ruleText);

    await updateOrderWithHistory(id, { rules }, "RULESADD", { rule: ruleText });
    await logAction("rules_add", { orderId:id });

    addMsg(`âœ… Rule added on ${id}`, "bot");
    setChips([`SHOWALL ${id}`, `RULESCLEAR ${id}`, "NEXT"]);
    return;
  }

  if(U.startsWith("RULESCLEAR ")){
    requireRole("manager");
    const token = clean(text.slice(11)) || state.lastOrderId;
    const id = await resolveOrderId(token);
    if(!id){ addMsg("Usage: RULESCLEAR <idOrNick>", "bot"); return; }

    await updateOrderWithHistory(id, { rules: [] }, "RULESCLEAR");
    await logAction("rules_clear", { orderId:id });

    addMsg(`âœ… Cleared rules on ${id}`, "bot");
    return;
  }

  /* =========================================================
     CHECKLIST
     CHECKADD <idOrNick> <step text> (manager+)
     CHECKLIST <idOrNick> (staff+)
     CHECKDONE <idOrNick> <step#> (staff+)
     CHECKUNDO <idOrNick> <step#> (staff can undo own, manager+ any)
  ========================================================= */
  if(U.startsWith("CHECKADD ")){
    requireRole("manager");

    const rest = text.slice(9).trim();
    const parts = rest.split(/\s+/);
    const token = parts[0] || state.lastOrderId;
    const stepText = rest.slice((parts[0]||"").length).trim();

    const id = await resolveOrderId(token);
    if(!id || !stepText){
      addMsg("Usage: CHECKADD <idOrNick> <step text>", "bot");
      return;
    }

    const ref = ordersCol().doc(id);
    const snap = await ref.get();
    if(!snap.exists){ addMsg("Order not found.", "bot"); return; }
    const d = snap.data() || {};
    const checklist = Array.isArray(d.checklist) ? d.checklist.slice(0, 40) : [];
    checklist.push({ text: stepText, done:false, doneAt:null, doneBy:"" });

    await updateOrderWithHistory(id, { checklist }, "CHECKADD", { step: stepText });
    await logAction("check_add", { orderId:id });

    addMsg(`âœ… Step added to ${id}`, "bot");
    setChips([`CHECKLIST ${id}`, `CHECKDONE ${id} ${checklist.length}`, "NEXT"]);
    return;
  }

  if(U.startsWith("CHECKLIST ")){
    requireRole("staff");
    const token = clean(text.slice(10)) || state.lastOrderId;
    const id = await resolveOrderId(token);
    if(!id){ addMsg("Usage: CHECKLIST <idOrNick>", "bot"); return; }

    const snap = await ordersCol().doc(id).get();
    if(!snap.exists){ addMsg("Order not found.", "bot"); return; }
    const d = snap.data() || {};
    const list = Array.isArray(d.checklist) ? d.checklist : [];

    if(!list.length){
      addMsg(`Checklist for ${id}: (none)\nAdmin can add steps with: CHECKADD ${id} <text>`, "bot");
      return;
    }

    const lines = list.map((s,i)=>{
      const done = s.done ? "âœ…" : "â¬œ";
      const who = s.doneBy ? ` by ${s.doneBy}` : "";
      const when = s.doneAt ? ` @ ${fmtDate(s.doneAt)}` : "";
      return `${i+1}) ${done} ${s.text}${who}${when}`;
    }).join("\n");

    addMsg(`Checklist for ${id}:\n${lines}`, "bot");
    setChips([`CHECKDONE ${id} 1`, `CHECKUNDO ${id} 1`, `SHOWALL ${id}`, "NEXT"]);
    return;
  }

  if(U.startsWith("CHECKDONE ")){
    requireRole("staff");

    const parts = text.split(/\s+/);
    const token = parts[1] || state.lastOrderId;
    const idx = Number(parts[2]);

    const id = await resolveOrderId(token);
    if(!id || !Number.isFinite(idx) || idx < 1){
      addMsg("Usage: CHECKDONE <idOrNick> <step#>", "bot");
      return;
    }

    const ref = ordersCol().doc(id);
    const snap = await ref.get();
    if(!snap.exists){ addMsg("Order not found.", "bot"); return; }
    const d = snap.data() || {};
    const checklist = Array.isArray(d.checklist) ? d.checklist : [];
    const i = idx - 1;
    if(!checklist[i]){ addMsg("Step not found.", "bot"); return; }

    checklist[i] = { ...checklist[i], done:true, doneAt: ts(), doneBy: session.username };

    await updateOrderWithHistory(id, { checklist }, "CHECKDONE", { stepNumber: idx, stepText: checklist[i].text });
    await logAction("check_done", { orderId:id, stepNumber: idx });

    addMsg(`âœ… Step ${idx} done on ${id}`, "bot");
    setChips([`CHECKLIST ${id}`, `SHOWALL ${id}`, "NEXT"]);
    return;
  }

  if(U.startsWith("CHECKUNDO ")){
    requireRole("staff");

    const parts = text.split(/\s+/);
    const token = parts[1] || state.lastOrderId;
    const idx = Number(parts[2]);

    const id = await resolveOrderId(token);
    if(!id || !Number.isFinite(idx) || idx < 1){
      addMsg("Usage: CHECKUNDO <idOrNick> <step#>", "bot");
      return;
    }

    const ref = ordersCol().doc(id);
    const snap = await ref.get();
    if(!snap.exists){ addMsg("Order not found.", "bot"); return; }
    const d = snap.data() || {};
    const checklist = Array.isArray(d.checklist) ? d.checklist : [];
    const i = idx - 1;
    if(!checklist[i]){ addMsg("Step not found.", "bot"); return; }

    if(checklist[i].doneBy && checklist[i].doneBy !== session.username && roleLevel(session.role) < roleLevel("manager")){
      addMsg("You can only undo steps you completed (unless manager+).", "bot");
      return;
    }

    checklist[i] = { ...checklist[i], done:false, doneAt:null, doneBy:"" };

    await updateOrderWithHistory(id, { checklist }, "CHECKUNDO", { stepNumber: idx });
    await logAction("check_undo", { orderId:id, stepNumber: idx });

    addMsg(`â†©ï¸ Step ${idx} undone on ${id}`, "bot");
    setChips([`CHECKLIST ${id}`, "NEXT"]);
    return;
  }

  // DONE / SHIPPED / PAID
  if(U.startsWith("DONE ") || U.startsWith("SHIPPED ") || U.startsWith("PAID ")){
    requireRole("staff");
    const parts = text.split(/\s+/);
    const verb = upper(parts[0]);
    const token = clean(parts.slice(1).join(" ")) || state.lastOrderId;
    const id = await resolveOrderId(token);
    if(!id){ addMsg(`${verb} needs an id/nickname (or use NEXT/SHOWALL).`, "bot"); return; }

    const patch = {};
    if(verb === "DONE"){ patch.status="done"; patch.doneAt=ts(); patch.doneBy=session.username; }
    if(verb === "SHIPPED"){ patch.shippedAt=ts(); }
    if(verb === "PAID"){ patch.paidAt=ts(); }

    await updateOrderWithHistory(id, patch, verb, { doneBy: verb==="DONE" ? session.username : "" });
    await logAction("update_order", { orderId:id, verb });

    addMsg(`âœ… ${verb} set for ${id}`, "bot");
    setChips([`SHOWALL ${id}`,"NEXT","MYQUEUE","MYASSIGNED"]);
    return;
  }

  // DELETE (manager+, safe confirm)
  if(U.startsWith("DELETE")){
    requireRole("manager");
    const rest = clean(text.slice(6)).trim();
    const parts = rest.split(/\s+/).filter(Boolean);
    const token = parts[0] || state.lastOrderId;
    const wantsConfirm = upper(parts.slice(1).join(" ")) === "CONFIRM";
    const id = await resolveOrderId(token);

    if(!id){ addMsg("DELETE needs an id/nickname (or use NEXT/SHOWALL).", "bot"); return; }

    if(!wantsConfirm){
      armDelete(id);
      addMsg(`âš ï¸ Delete armed for 60 seconds.\nType: DELETE ${token} CONFIRM`, "bot");
      setChips([`DELETE ${token} CONFIRM`, `SHOWALL ${token}`, "HELP"]);
      return;
    }

    if(!canConfirmDelete(id)){
      addMsg("Delete confirm expired (or not armed). Type DELETE <id> first.", "bot");
      return;
    }

    await ordersCol().doc(id).delete();
    bustOrders();
    await logAction("delete_order", { orderId:id });
    addMsg(`ðŸ—‘ï¸ Deleted order: ${id}`, "bot");
    setChips(["NEXT","UNPAID","HELP"]);
    return;
  }

  // BYPHONE
  if(U.startsWith("BYPHONE ")){
    const digs = digitsOnly(text.slice(8));
    const rows = await ensureOrdersFresh();
    const out = rows.filter(r=>{
      const p = digitsOnly(r?.order?.phone || "");
      return p === digs;
    }).sort((a,b)=>orderCreatedDate(b)-orderCreatedDate(a)).slice(0,120);

    addMsg(formatOrderList(out, `BYPHONE ${digs}`), "bot");
    return;
  }

  // Unknown fallback
  addMsg("I didnâ€™t recognize that. Type HELP.", "bot");
  setChips(["HELP","NEXT","UNPAID","UNFINISHED","WHOAMI"]);
}

/* =========================
   Chat wrapper
========================= */
async function handleChat(raw){
  const text = clean(raw);
  if(!text) return;
  const cmd = interpretNatural(text);
  await handleCommand(cmd);
}

/* =========================
   Send
========================= */
async function send(){
  const raw = input.value;
  input.value = "";
  if(!clean(raw)) return;

  addMsg(raw, "user");
  try{
    setStatus("");
    await handleChat(raw);
  }catch(err){
    console.error(err);
    setStatus("âš ï¸ " + (err?.message || String(err)));
    addMsg("âš ï¸ Error. Type HELP.", "bot");
    setChips(["HELP","WHOAMI","LOGIN 00000 owner pass","NEWBIZ MyBiz pass"]);
  }
}
document.getElementById("sendBtn").addEventListener("click", send);
input.addEventListener("keydown", (e)=>{ if(e.key === "Enter") send(); });

document.getElementById("resetBtn").addEventListener("click", ()=>{
  chat.innerHTML = "";
  setStatus("");
  state.lastOrderId = "";
  state.learnMode = null;
  state.learnTrigger = "";
  addMsg("Reset âœ…\nTry: HELP", "bot");
  setChips(["HELP","NEWBIZ TacticsTreats mypass","LOGIN 00000 owner pass","WHOAMI"]);
});

/* Boot */
(function init(){
  addMsg(
`Howdy ðŸ¤ 

This is the FULL admin:
â€¢ Multi-business (auto 5-digit code)
â€¢ Owner / Manager / Staff
â€¢ Assign orders to users + instructions
â€¢ Add rules + checklist steps
â€¢ Track who finished steps + who marked DONE (doneBy + doneAt)
â€¢ Show full order details with SHOWALL

Start:
1) NEWBIZ TacticsTreats mypass
2) It gives you a 5-digit business code
3) LOGIN <code> owner mypass`,
  "bot"
  );
  setChips(["HELP","NEWBIZ TacticsTreats mypass","LOGIN 00000 owner pass","WHOAMI","NEXT"]);
  setStatus("âœ… Ready");
})();
</script>
</body>
</html>
```
