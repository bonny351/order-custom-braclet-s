<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Tactics & Treats â€“ Smart Admin Bot (Full Updated)</title>

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;800&display=swap" rel="stylesheet">

<style>
  :root{
    --bg:#0b0b0b; --panel:#141414; --panel2:#0f0f0f;
    --text:#fff; --muted:#c9c9c9; --accent:#ff2a2a;
    --line:#2a2a2a; --radius:16px;
  }
  *{ box-sizing:border-box; }
  body{
    margin:0; padding:16px;
    background:var(--bg); color:var(--text);
    font-family:"Poppins",system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
  }
  .wrap{ max-width:1040px; margin:0 auto; }
  header{
    display:flex; align-items:center; justify-content:space-between;
    gap:12px; flex-wrap:wrap; margin-bottom:12px;
  }
  h1{ margin:0; color:var(--accent); font-size:20px; }
  .pill{
    font-size:12px; padding:6px 10px; border-radius:999px;
    background:#1f1f1f; border:1px solid #2a2a2a; color:var(--muted);
  }
  .card{
    background:var(--panel);
    border:1px solid #262626;
    border-radius:var(--radius);
    padding:14px;
    box-shadow:0 0 18px rgba(255,0,0,.16);
  }
  .chat{
    height:62vh; min-height:380px; max-height:720px;
    overflow:auto;
    padding:12px;
    border-radius:14px;
    background:#000;
    border:1px solid var(--line);
  }
  .msg{
    max-width:94%;
    padding:10px 12px;
    border-radius:14px;
    margin:10px 0;
    white-space:pre-line;
    line-height:1.35;
    word-break:break-word;
  }
  .bot{
    background:#101010;
    border:1px solid #2a2a2a;
    border-top-left-radius:6px;
  }
  .user{
    background:#1c1c1c;
    border:1px solid #333;
    margin-left:auto;
    border-top-right-radius:6px;
  }
  .chips{
    display:flex; flex-wrap:wrap; gap:8px; margin-top:10px;
  }
  .chip{
    background:#191919;
    border:1px solid #2f2f2f;
    color:#fff;
    padding:8px 10px;
    border-radius:999px;
    cursor:pointer;
    font-size:13px;
    font-weight:800;
    user-select:none;
  }
  .chip:hover{ filter:brightness(1.08); }
  .bar{ display:flex; gap:10px; margin-top:10px; }
  input{
    flex:1;
    border:none; outline:none;
    border-radius:14px;
    padding:12px 12px;
    font-size:15px;
    color:#fff;
    background:var(--panel2);
    border:1px solid var(--line);
  }
  button{
    border:none;
    border-radius:14px;
    padding:12px 14px;
    font-weight:900;
    cursor:pointer;
    background:var(--accent);
    color:#fff;
  }
  button:hover{ filter:brightness(1.08); }
  .secondary{
    background:#242424;
    border:1px solid #343434;
    color:#fff;
  }
  #status{
    margin-top:10px;
    color:#ffb347;
    font-weight:800;
    min-height:18px;
    white-space:pre-line;
  }
  .meta{
    font-size:12px; color:var(--muted); margin-top:10px; line-height:1.35;
  }
  .meta b{ color:#fff; }
</style>
</head>

<body>
<div class="wrap">
  <header>
    <h1>Tactics & Treats â€“ Admin Bot (Full Updated)</h1>
    <div class="pill">Natural chat â€¢ SHOWALL â€¢ Nicknames â€¢ Bulk â€¢ DBSCAN â€¢ SCANFIX</div>
  </header>

  <div class="card">
    <div id="chat" class="chat"></div>
    <div id="chips" class="chips"></div>
    <div id="status"></div>

    <div class="bar">
      <input id="input" placeholder="Talk to meâ€¦ (try: NEXT, showall john rush, unpaid, bulk)" autocomplete="off" />
      <button id="sendBtn" type="button">Send</button>
      <button id="resetBtn" type="button" class="secondary">Reset</button>
    </div>

    <div class="meta">
      Quick: <b>HELP</b>, <b>NEXT</b>, <b>UNPAID</b>, <b>UNFINISHED</b>, <b>MONTHLY GROSS</b>,
      <b>SHOWALL</b>, <b>DBSCAN</b>, <b>SCANFIX</b>, <b>BULK</b>, <b>ALIASES</b>
    </div>
  </div>
</div>

<!-- Firebase compat (easy hosting) -->
<script src="https://www.gstatic.com/firebasejs/11.0.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/11.0.1/firebase-firestore-compat.js"></script>

<script>
/* =========================
   FIREBASE (your project)
========================= */
firebase.initializeApp({
  apiKey:"AIzaSyCiZuaANb1lrgdn-aARGJ_TRhgzPPUug58",
  authDomain:"bracelets-and-color.firebaseapp.com",
  projectId:"bracelets-and-color",
  storageBucket:"bracelets-and-color.appspot.com",
  messagingSenderId:"382292570673",
  appId:"1:382292570673:web:1c966e2e7e8fc2efa31b10"
});
const db = firebase.firestore();
const ts = () => firebase.firestore.FieldValue.serverTimestamp();

/* =========================
   COLLECTIONS
========================= */
const ORDERS = "tt_orders";
const SKILLS = "tt_skills";
const ALIASES = "tt_order_aliases"; // nickname -> orderId
const PRODUCTS = {
  bracelets: "products_bracelets",
  cookies: "products_cookies",
};

const DB_COLLECTIONS = [
  { key:"orders", name: ORDERS, limit: 500 },
  { key:"skills", name: SKILLS, limit: 500 },
  { key:"aliases", name: ALIASES, limit: 500 },
  { key:"bracelets", name: PRODUCTS.bracelets, limit: 500 },
  { key:"cookies", name: PRODUCTS.cookies, limit: 500 },
];

/* =========================
   UI
========================= */
const chat = document.getElementById("chat");
const input = document.getElementById("input");
const chipsBox = document.getElementById("chips");
const statusEl = document.getElementById("status");

function setStatus(msg){ statusEl.textContent = msg || ""; }
function addMsg(text, who="bot"){
  const div = document.createElement("div");
  div.className = "msg " + (who === "user" ? "user" : "bot");
  div.textContent = text;
  chat.appendChild(div);
  chat.scrollTop = chat.scrollHeight;
}
function setChips(options){
  chipsBox.innerHTML = "";
  (options || []).forEach(opt=>{
    const b = document.createElement("div");
    b.className = "chip";
    b.textContent = opt;
    b.onclick = ()=>{ input.value = opt; send(); };
    chipsBox.appendChild(b);
  });
}
function clean(s){ return String(s||"").trim(); }
function lower(s){ return clean(s).toLowerCase(); }
function upper(s){ return clean(s).toUpperCase(); }
function digitsOnly(s){ return String(s||"").replace(/[^\d]/g,""); }
function money(v){
  const n = Number(v);
  return Number.isFinite(n) ? "$" + n.toFixed(2) : "$0.00";
}
function safeToDate(v){
  if(!v) return null;
  if(typeof v?.toDate === "function") return v.toDate();
  if(typeof v?.seconds === "number") return new Date(v.seconds*1000);
  const d = new Date(v);
  return isNaN(d.getTime()) ? null : d;
}
function fmtDate(v){
  const d = safeToDate(v);
  return d ? d.toLocaleString() : "";
}
function normalizeStatus(s){
  const t = String(s||"new").toLowerCase().trim();
  if(["new","pending","unpaid","done","archived","cancelled","refunded","flagged"].includes(t)) return t;
  if(t === "completed") return "done";
  return t || "new";
}
function startOfToday(){ const d=new Date(); d.setHours(0,0,0,0); return d; }
function startOfWeek(){ const d=startOfToday(); const day=d.getDay(); d.setDate(d.getDate()-day); return d; }
function startOfMonth(){ const d=startOfToday(); d.setDate(1); return d; }
function orderCreatedDate(r){ return safeToDate(r.createdAt) || new Date(0); }
function isToday(r){ return orderCreatedDate(r) >= startOfToday(); }
function isThisWeek(r){ return orderCreatedDate(r) >= startOfWeek(); }
function isThisMonth(r){ return orderCreatedDate(r) >= startOfMonth(); }

function orderTotal(r){
  const n = Number(r?.totals?.total);
  return Number.isFinite(n) ? n : 0;
}

/* =========================
   DISPLAY: EVERYTHING ABOUT ITEMS + ORDER
========================= */
function summarizeItems(items){
  if(!Array.isArray(items) || !items.length) return "(none)";

  const pickExtras = (it)=>{
    const extras = [];
    for(const [k,v] of Object.entries(it || {})){
      if(v === undefined || v === null) continue;
      if(v === "" ) continue;
      if(Array.isArray(v) && v.length === 0) continue;
      if(typeof v === "boolean" && v === false) continue;

      // skip fields we already print nicely below
      if(["itemType","weave","inches","fit","colors","patternStyle"].includes(k)) continue;

      extras.push(`${k}: ${Array.isArray(v) ? v.join(", ") : String(v)}`);
    }
    return extras;
  };

  return items.map((it, i)=>{
    const colors = Array.isArray(it.colors) ? it.colors.join(" / ") : "";
    const extras = pickExtras(it);

    return [
      `${i+1}) ${it.itemType || "(item)"}`,
      `   â€¢ weave: ${it.weave || ""}`,
      `   â€¢ size: ${it.inches || ""}"`,
      `   â€¢ fit: ${it.fit || ""}`,
      `   â€¢ colors: ${colors || "(none)"}`,
      `   â€¢ pattern: ${it.patternStyle || "(none)"}`,
      extras.length ? `   â€¢ extras:\n     - ${extras.join("\n     - ")}` : `   â€¢ extras: (none)`
    ].join("\n");
  }).join("\n\n");
}

function orderCard(id, data){
  const o = data?.order || {};
  const status = normalizeStatus(data?.status);

  const totals = data?.totals || {};
  const totalNum = Number(totals.total);
  const totalTxt = Number.isFinite(totalNum) ? money(totalNum) : (totals.total ?? "");

  // Known top-level fields (everything else gets printed under EXTRA FIELDS)
  const knownTop = new Set([
    "status","createdAt","order","items","totals",
    "assignedTo","adminNote","tracking","flagged","problemNote",
    "paidAt","shippedAt","doneAt",
    "notes","giftNote","giftNoteText","trackingUpgrade","packaging","photoBeforePay",
    "donation","coupon"
  ]);

  // Print any unknown top fields too
  const extraTop = [];
  for(const [k,v] of Object.entries(data || {})){
    if(knownTop.has(k)) continue;
    if(v === undefined || v === null) continue;
    if(v === "" ) continue;
    if(Array.isArray(v) && v.length === 0) continue;
    if(typeof v === "boolean" && v === false) continue;

    if(typeof v?.toDate === "function") extraTop.push(`${k}: ${fmtDate(v)}`);
    else extraTop.push(`${k}: ${Array.isArray(v) ? JSON.stringify(v) : String(v)}`);
  }

  const totalsLines = [];
  for(const [k,v] of Object.entries(totals || {})){
    if(v === undefined || v === null) continue;
    if(typeof v === "number") totalsLines.push(`  â€¢ ${k}: ${money(v)}`);
    else totalsLines.push(`  â€¢ ${k}: ${String(v)}`);
  }

  const orderLines = [];
  for(const [k,v] of Object.entries(o || {})){
    if(v === undefined || v === null) continue;
    if(v === "" ) continue;
    if(typeof v === "boolean" && v === false) continue;
    orderLines.push(`  â€¢ ${k}: ${String(v)}`);
  }

  return [
    `ORDER FULL DETAILS`,
    `Order ID: ${id}`,
    `Status: ${status}`,
    `Created: ${fmtDate(data?.createdAt)}`,
    ``,
    `Customer / Shipping (order object):`,
    orderLines.length ? orderLines.join("\n") : "  (none)",
    ``,
    `Admin fields:`,
    `  â€¢ assignedTo: ${data?.assignedTo || ""}`,
    `  â€¢ adminNote: ${data?.adminNote || ""}`,
    `  â€¢ tracking: ${data?.tracking || ""}`,
    `  â€¢ flagged: ${data?.flagged ? "yes" : "no"}`,
    `  â€¢ problemNote: ${data?.problemNote || ""}`,
    `  â€¢ paidAt: ${fmtDate(data?.paidAt)}`,
    `  â€¢ shippedAt: ${fmtDate(data?.shippedAt)}`,
    `  â€¢ doneAt: ${fmtDate(data?.doneAt)}`,
    ``,
    `Customer extras:`,
    `  â€¢ notes: ${data?.notes || ""}`,
    `  â€¢ giftNote: ${data?.giftNote ? "yes" : "no"}`,
    `  â€¢ giftNoteText: ${data?.giftNoteText || ""}`,
    `  â€¢ trackingUpgrade: ${data?.trackingUpgrade ? "yes" : "no"}`,
    `  â€¢ packaging: ${data?.packaging ? "yes" : "no"}`,
    `  â€¢ photoBeforePay: ${data?.photoBeforePay ? "yes" : "no"}`,
    `  â€¢ coupon: ${data?.coupon || ""}`,
    `  â€¢ donation: ${money(data?.donation || 0)}`,
    ``,
    `Totals:`,
    totalsLines.length ? totalsLines.join("\n") : "  (none)",
    `  â€¢ total_display: ${totalTxt}`,
    ``,
    `Items:`,
    summarizeItems(data?.items || []),
    ``,
    extraTop.length ? `EXTRA FIELDS:\n${extraTop.map(x=>"â€¢ "+x).join("\n")}` : "EXTRA FIELDS: (none)"
  ].join("\n");
}

function compactOrderLine(r){
  const o = r.order || {};
  const t = orderTotal(r);
  return `â€¢ ${r.id} | ${normalizeStatus(r.status)} | ${o.name||""} | ${o.phone||""} | ${money(t)}`;
}
function formatOrderList(rows, title){
  if(!rows.length) return `${title}: none found.`;
  return [
    `${title} (showing ${rows.length}):`,
    ...rows.map(compactOrderLine)
  ].join("\n");
}

/* =========================
   CACHES (fast)
========================= */
let orderCache = [];
let orderCacheAt = 0;

let skillsCache = [];
let skillsCacheAt = 0;

let aliasCache = [];
let aliasCacheAt = 0;

const TTL = 15000;
const ORDER_FETCH_LIMIT = 900;

async function refreshOrders(){
  const snap = await db.collection(ORDERS).limit(ORDER_FETCH_LIMIT).get();
  orderCache = snap.docs.map(d=>({ id:d.id, ...d.data() }));
  orderCacheAt = Date.now();
  return orderCache;
}
async function ensureOrdersFresh(){
  if(!orderCache.length || (Date.now() - orderCacheAt) > TTL) await refreshOrders();
  return orderCache;
}

async function refreshSkills(){
  const snap = await db.collection(SKILLS).limit(900).get();
  skillsCache = snap.docs.map(d=>({ id:d.id, ...d.data() }));
  skillsCacheAt = Date.now();
  return skillsCache;
}
async function ensureSkillsFresh(){
  if(!skillsCache.length || (Date.now() - skillsCacheAt) > TTL) await refreshSkills();
  return skillsCache;
}

async function refreshAliases(){
  const snap = await db.collection(ALIASES).limit(900).get();
  aliasCache = snap.docs.map(d=>({ id:d.id, ...d.data() }));
  aliasCacheAt = Date.now();
  return aliasCache;
}
async function ensureAliasesFresh(){
  if(!aliasCache.length || (Date.now() - aliasCacheAt) > TTL) await refreshAliases();
  return aliasCache;
}

function bustOrders(){ orderCacheAt = 0; }
function bustSkills(){ skillsCacheAt = 0; }
function bustAliases(){ aliasCacheAt = 0; }

/* =========================
   ALIASES (nicknames)
========================= */
function normAlias(s){
  return String(s||"")
    .toLowerCase()
    .trim()
    .replace(/\s+/g," ")
    .replace(/[^\w\s-]/g,"");
}
function looksLikeId(tok){
  const t = String(tok||"").trim();
  if(!t) return false;
  if(t.length < 4) return false;
  if(t.includes(" ")) return false;
  return /[a-z0-9]/i.test(t);
}
async function setAlias(alias, orderId){
  const a = normAlias(alias);
  if(!a) throw new Error("Alias is empty.");
  if(!orderId) throw new Error("OrderId missing.");
  await db.collection(ALIASES).doc(a).set({
    alias: a,
    orderId: String(orderId).trim(),
    updatedAt: ts()
  }, { merge:true });
  bustAliases();
}
async function getAlias(alias){
  const a = normAlias(alias);
  const snap = await db.collection(ALIASES).doc(a).get();
  return snap.exists ? snap.data() : null;
}
async function deleteAlias(alias){
  const a = normAlias(alias);
  await db.collection(ALIASES).doc(a).delete();
  bustAliases();
}
async function listAliases(limit=80){
  const snap = await db.collection(ALIASES).limit(limit).get();
  return snap.docs.map(d=>d.data());
}
async function resolveOrderId(token){
  const t = String(token||"").trim();
  if(!t) return "";
  if(looksLikeId(t)) return t;
  const hit = await getAlias(t);
  return hit?.orderId || "";
}

/* =========================
   SKILLS (learn)
========================= */
async function saveSkill(trigger, action){
  await db.collection(SKILLS).add({
    trigger: normAlias(trigger),
    action: String(action||"").trim(),
    createdAt: ts()
  });
  bustSkills();
}
async function deleteSkillByTrigger(trigger){
  const trg = normAlias(trigger);
  const snap = await db.collection(SKILLS).where("trigger","==",trg).limit(80).get();
  const batch = db.batch();
  snap.docs.forEach(d=>batch.delete(d.ref));
  await batch.commit();
  bustSkills();
}

/* =========================
   DBSCAN (schema-ish)
========================= */
function typeOfValue(v){
  if(v === null) return "null";
  if(Array.isArray(v)) return "array";
  if(typeof v?.toDate === "function") return "timestamp";
  const t = typeof v;
  if(t === "object") return "object";
  return t;
}
function mergeType(map, key, t){
  if(!map[key]) map[key] = new Set();
  map[key].add(t);
}
function walkSchema(obj, prefix, map){
  if(!obj || typeof obj !== "object") return;
  for(const k of Object.keys(obj)){
    const path = prefix ? `${prefix}.${k}` : k;
    const v = obj[k];
    const t = typeOfValue(v);
    mergeType(map, path, t);
    if(t === "object") walkSchema(v, path, map);
  }
}
function schemaReport(docs){
  const map = {};
  for(const d of docs) walkSchema(d, "", map);
  const keys = Object.keys(map).sort();
  if(!keys.length) return "(no fields)";
  return keys.map(k=>`â€¢ ${k}: ${Array.from(map[k]).sort().join(" | ")}`).join("\n");
}
async function scanCollection(colName, lim){
  const snap = await db.collection(colName).limit(lim).get();
  return snap.docs.map(d=>({ id:d.id, ...d.data() }));
}
function summarizeOrders(docs){
  const statusCount = {};
  let doneRevenue = 0;
  for(const o of docs){
    const s = normalizeStatus(o.status);
    statusCount[s] = (statusCount[s]||0)+1;
    if(s==="done") doneRevenue += orderTotal(o);
  }
  const lines = Object.keys(statusCount).sort().map(k=>`â€¢ ${k}: ${statusCount[k]}`);
  return [
    `Orders scanned: ${docs.length}`,
    `Done revenue (scanned): ${money(doneRevenue)}`,
    `Status breakdown:\n${lines.join("\n") || "(none)"}`
  ].join("\n");
}
function summarizeAliases(docs){
  const sample = docs.slice(0, 12).map(a=>`â€¢ "${a.alias}" â†’ ${a.orderId}`).join("\n") || "(none)";
  return `Aliases scanned: ${docs.length}\nSample:\n${sample}`;
}
function summarizeSkills(docs){
  const sample = docs.slice(0, 12).map(s=>`â€¢ "${s.trigger}" â†’ ${s.action}`).join("\n") || "(none)";
  return `Skills scanned: ${docs.length}\nSample:\n${sample}`;
}
function summarizeProducts(docs){
  let low=0,out=0;
  for(const p of docs){
    const stock = Number(p.stock);
    if(Number.isFinite(stock)){
      if(stock<=0) out++;
      else if(stock<=3) low++;
    }
  }
  return `Products scanned: ${docs.length}\nOut of stock: ${out}\nLow stock (<=3): ${low}`;
}
async function dbScanAll(){
  const blocks = [];
  for(const c of DB_COLLECTIONS){
    const docs = await scanCollection(c.name, c.limit);
    let summary = "";
    if(c.name === ORDERS) summary = summarizeOrders(docs);
    else if(c.name === SKILLS) summary = summarizeSkills(docs);
    else if(c.name === ALIASES) summary = summarizeAliases(docs);
    else summary = summarizeProducts(docs);

    blocks.push(
      `=== ${c.name} ===\n` +
      summary + "\n\n" +
      `Schema (inferred):\n` +
      schemaReport(docs.slice(0, 80))
    );
  }
  return blocks.join("\n\n");
}

/* =========================
   SCANFIX (safe plan + confirm)
========================= */
const FIX_RULES = {
  ensureOrderStatus: true,
  ensureCreatedAt: true,
  ensurePhoneDigits: true,
  ensureTotalsNumber: true,
  normalizeSkillTrigger: true,
  ensureProductStockNumber: true
};
function isTimestamp(v){ return v && typeof v.toDate === "function"; }

async function scanCollectionWithRefs(col, lim){
  const snap = await db.collection(col).limit(lim).get();
  return snap.docs.map(d => ({ __id: d.id, __ref: d.ref, ...d.data() }));
}
function addFix(plan, ref, id, patch, reason){
  if(!patch || !Object.keys(patch).length) return;
  plan.fixes.push({ ref, id, patch, reason });
}
async function buildFixPlan(){
  const plan = { createdAt: new Date().toISOString(), fixes: [], summary: [] };

  // ORDERS fixes
  {
    const orders = await scanCollectionWithRefs(ORDERS, 500);
    let missingStatus=0, normedStatus=0, missingCreated=0, phoneFixed=0, totalsFixed=0;

    for(const o of orders){
      const patch = {};

      if(FIX_RULES.ensureOrderStatus){
        if(o.status == null){
          patch.status = "new"; missingStatus++;
        }else{
          const ns = normalizeStatus(o.status);
          if(ns !== o.status){ patch.status = ns; normedStatus++; }
        }
      }

      if(FIX_RULES.ensureCreatedAt){
        const ok = o.createdAt && (isTimestamp(o.createdAt) || typeof o.createdAt === "string" || typeof o.createdAt === "number");
        if(!ok){ patch.createdAt = ts(); missingCreated++; }
      }

      if(FIX_RULES.ensurePhoneDigits){
        const phone = o?.order?.phone || "";
        const digs = digitsOnly(o?.order?.phoneDigits || phone);
        if(digs && o?.order?.phoneDigits !== digs){
          patch["order.phoneDigits"] = digs;
          phoneFixed++;
        }
      }

      if(FIX_RULES.ensureTotalsNumber){
        const t = o?.totals?.total;
        if(t != null && typeof t !== "number"){
          const n = Number(t);
          if(Number.isFinite(n)){ patch["totals.total"] = n; totalsFixed++; }
        }
      }

      addFix(plan, o.__ref, o.__id, patch, "orders normalize fields");
    }

    plan.summary.push(
      `Orders scanned: ${orders.length}`,
      `â€¢ Missing status set: ${missingStatus}`,
      `â€¢ Status normalized: ${normedStatus}`,
      `â€¢ Missing createdAt set: ${missingCreated}`,
      `â€¢ order.phoneDigits fixed: ${phoneFixed}`,
      `â€¢ totals.total converted: ${totalsFixed}`
    );
  }

  // SKILLS fixes
  if(FIX_RULES.normalizeSkillTrigger){
    const skills = await scanCollectionWithRefs(SKILLS, 500);
    let trig=0;
    for(const s of skills){
      const patch = {};
      if(typeof s.trigger === "string"){
        const nt = normAlias(s.trigger);
        if(nt !== s.trigger){ patch.trigger = nt; trig++; }
      }
      addFix(plan, s.__ref, s.__id, patch, "skills normalize trigger");
    }
    plan.summary.push(`Skills scanned: ${skills.length}`, `â€¢ Triggers normalized: ${trig}`);
  }

  // PRODUCT stock -> number
  if(FIX_RULES.ensureProductStockNumber){
    for(const col of [PRODUCTS.bracelets, PRODUCTS.cookies]){
      const prods = await scanCollectionWithRefs(col, 500);
      let stockFixed=0;
      for(const p of prods){
        const patch = {};
        if(p.stock != null && typeof p.stock !== "number"){
          const n = Number(p.stock);
          if(Number.isFinite(n)){ patch.stock = n; stockFixed++; }
        }
        addFix(plan, p.__ref, p.__id, patch, `${col} stock -> number`);
      }
      plan.summary.push(`${col} scanned: ${prods.length}`, `â€¢ stock converted: ${stockFixed}`);
    }
  }

  return plan;
}
async function applyFixPlan(plan){
  const MAX_WRITES = 250; // safety cap
  const fixes = plan.fixes.slice(0, MAX_WRITES);

  let ok=0, fail=0;
  const BATCH = 400;

  for(let i=0;i<fixes.length;i+=BATCH){
    const batch = db.batch();
    const chunk = fixes.slice(i, i+BATCH);
    for(const f of chunk) batch.update(f.ref, f.patch);

    try{
      await batch.commit();
      ok += chunk.length;
    }catch(e){
      for(const f of chunk){
        try{ await f.ref.update(f.patch); ok++; }
        catch(err){ fail++; }
      }
    }
  }
  return { ok, fail, total: fixes.length };
}

/* =========================
   BULK IMPORT (aliases + skills)
========================= */
const bulk = { waiting:false, parsed:null };

function parseBulkBlock(text){
  const lines = String(text||"")
    .split(/\r?\n/)
    .map(l=>l.trim())
    .filter(l=>l && !l.startsWith("#"));

  const first = lines[0] || "";
  if(first.includes("->")) return { mode:"SKILLS", items: parseSkills(lines) };
  if(first.includes("="))  return { mode:"ALIASES", items: parseAliases(lines) };
  return { mode:"UNKNOWN", items: [] };
}
function parseAliases(lines){
  const out = [];
  for(const l of lines){
    const m = l.split("=");
    if(m.length < 2) continue;
    const alias = normAlias(m[0]);
    const orderId = String(m.slice(1).join("=").trim());
    if(alias && orderId) out.push({ alias, orderId });
  }
  return out;
}
function parseSkills(lines){
  const out = [];
  for(const l of lines){
    const m = l.split("->");
    if(m.length < 2) continue;
    const trigger = normAlias(m[0]);
    const action = String(m.slice(1).join("->").trim());
    if(trigger && action) out.push({ trigger, action });
  }
  return out;
}
async function bulkWriteAliases(items){
  const batch = db.batch();
  const slice = items.slice(0, 400);
  for(const it of slice){
    const ref = db.collection(ALIASES).doc(it.alias);
    batch.set(ref, { alias: it.alias, orderId: it.orderId, updatedAt: ts() }, { merge:true });
  }
  await batch.commit();
  bustAliases();
}
async function bulkWriteSkills(items){
  const batch = db.batch();
  const slice = items.slice(0, 400);
  for(const it of slice){
    const ref = db.collection(SKILLS).doc();
    batch.set(ref, { trigger: it.trigger, action: it.action, createdAt: ts() }, { merge:true });
  }
  await batch.commit();
  bustSkills();
}

/* =========================
   WORKFLOW + PRIORITY
========================= */
function priorityScore(r){
  const s = normalizeStatus(r.status);
  const rush = !!(r.order && r.order.rush);
  if(s === "unpaid" && rush) return 1;
  if(s === "unpaid") return 2;
  if(s === "pending" && rush) return 3;
  if(s === "pending") return 4;
  if(s === "new" && rush) return 5;
  if(s === "new") return 6;
  return 99;
}
function pickNext(rows){
  const unfinished = rows.filter(r=>!["done","archived","cancelled","refunded"].includes(normalizeStatus(r.status)));
  unfinished.sort((a,b)=>{
    const sa = priorityScore(a), sb = priorityScore(b);
    if(sa !== sb) return sa - sb;
    return orderCreatedDate(a).getTime() - orderCreatedDate(b).getTime();
  });
  return unfinished[0] || null;
}

/* =========================
   MAIN STATE
========================= */
const state = {
  lastOrderId: "",
  awaitingLearnConfirm: null,
  awaitingLearnAction: null,
  learnTemp: null,
  pendingFixPlan: null,
};

/* =========================
   HELP
========================= */
function helpText(){
  return [
    "ADMIN BOT COMMANDS (FULL UPDATED)",
    "",
    "Core:",
    "  NEXT | UNFINISHED | UNPAID | NEW | PENDING | DONE | TODAY | WEEK | MONTH | PRIORITY",
    "  SHOW <idOrNickname> | SHOWALL <idOrNickname>",
    "  DONE <idOrNickname> | SHIPPED <idOrNickname> | PAID <idOrNickname>",
    "",
    "Nicknames:",
    "  NICK <id> <nickname>     (or: NICK <nickname> uses last shown order)",
    "  ALIASES | UNNICK <nickname>",
    "",
    "Money / stats:",
    "  MONTHLY GROSS | WEEKLY GROSS | TODAY GROSS",
    "  TOTALS TODAY|WEEK|MONTH",
    "",
    "Database tools:",
    "  DBSCAN",
    "  SCANFIX   (plan)  â†’  SCANFIX CONFIRM (apply fixes safely)",
    "",
    "Learning:",
    "  LISTSKILLS | FORGET <trigger>",
    "",
    "Bulk import:",
    "  BULK  (then paste)",
    "  BULK CONFIRM | BULK CANCEL",
    "",
    "Tip: You can type normal phrases like â€œmark john rush doneâ€ or â€œshowall cookie ladyâ€.",
  ].join("\n");
}

/* =========================
   NATURAL -> COMMAND
========================= */
function interpretNatural(text){
  const t = clean(text);
  const L = t.toLowerCase();
  const U = t.toUpperCase();

  // learn flow
  if(state.awaitingLearnConfirm){
    if(["yes","y","yeah","yep","sure","ok"].includes(L)){
      state.awaitingLearnAction = String(state.awaitingLearnConfirm).trim();
      state.awaitingLearnConfirm = null;
      return "__ASK_LEARN_ACTION__";
    }
    if(["no","n","nope","nah"].includes(L)){
      state.awaitingLearnConfirm = null;
      return "__LEARN_CANCEL__";
    }
  }
  if(state.awaitingLearnAction){
    state.learnTemp = { trigger: state.awaitingLearnAction, action: t };
    state.awaitingLearnAction = null;
    return "__SAVE_SKILL__";
  }

  if(L === "help" || L === "?") return "HELP";

  if(L.includes("dbscan") || (L.includes("scan") && (L.includes("firebase") || L.includes("database")))) return "DBSCAN";
  if(L.includes("scanfix") || (L.includes("scan") && L.includes("fix"))){
    if(L.includes("confirm")) return "SCANFIX CONFIRM";
    return "SCANFIX";
  }

  if(L.startsWith("bulk confirm")) return "BULK CONFIRM";
  if(L.startsWith("bulk cancel")) return "BULK CANCEL";
  if(L === "bulk") return "BULK";

  if(L === "monthly gross" || (L.includes("monthly") && (L.includes("gross") || L.includes("revenue")))) return "REVENUE MONTH";
  if(L === "weekly gross" || (L.includes("weekly") && (L.includes("gross") || L.includes("revenue")))) return "REVENUE WEEK";
  if(L === "today gross" || (L.includes("today") && (L.includes("gross") || L.includes("revenue")))) return "REVENUE TODAY";

  if(L.startsWith("totals ")){
    const r = upper(L.split(/\s+/)[1]||"MONTH");
    return `TOTALS ${r}`;
  }

  if(L.includes("what's next") || L.includes("whats next") || L === "next") return "NEXT";
  if(L.includes("priority")) return "PRIORITY";
  if(L.includes("unfinished")) return "UNFINISHED";
  if(L.includes("unpaid")) return "UNPAID";

  if(L.startsWith("nick ")) return "NICK " + t.slice(5);
  if(L.startsWith("aliases")) return "ALIASES";
  if(L.startsWith("unnick ")) return "UNNICK " + t.slice(7);

  if(L.startsWith("showall ")){ return "SHOWALL " + clean(t.slice(8)); }
  if(L.startsWith("show ")){ return "SHOW " + clean(t.slice(5)); }

  if(L.includes("mark") && (L.includes("done") || L.includes("complete"))){
    const rest = L.replace("mark","").replace("as","").replace("done","").replace("complete","").replace("completed","").trim();
    const idOrNick = rest || state.lastOrderId;
    return "DONE " + idOrNick;
  }
  if(L.includes("shipped") || (L.includes("mark") && L.includes("ship"))){
    const rest = L.replace("mark","").replace("as","").replace("shipped","").replace("ship","").trim();
    const idOrNick = rest || state.lastOrderId;
    return "SHIPPED " + idOrNick;
  }
  if(L.includes("paid") && L.includes("mark")){
    const rest = L.replace("mark","").replace("as","").replace("paid","").trim();
    const idOrNick = rest || state.lastOrderId;
    return "PAID " + idOrNick;
  }

  // phone => BYPHONE
  const digs = digitsOnly(t);
  if(digs.length >= 7) return "BYPHONE " + digs;

  // default: FIND
  return "FIND " + t;
}

/* =========================
   COMMAND EXECUTOR
========================= */
async function handleCommand(raw){
  const text = clean(raw);
  const U = upper(text);
  if(!text) return;

  // learn system internal commands
  if(U === "__ASK_LEARN_ACTION__"){
    setStatus("");
    addMsg(
      "I can learn that.\n\n" +
      "What should I do when you say that?\n\n" +
      "Examples actions:\n" +
      "â€¢ NEXT\nâ€¢ UNPAID\nâ€¢ SHOWALL <id>\nâ€¢ REVENUE MONTH\nâ€¢ DBSCAN\nâ€¢ SCANFIX\n\n" +
      "Now type the action exactly how you want it saved.",
      "bot"
    );
    return;
  }
  if(U === "__LEARN_CANCEL__"){
    setStatus("");
    addMsg("Okay â€” I wonâ€™t learn that.", "bot");
    return;
  }
  if(U === "__SAVE_SKILL__"){
    const tgr = state.learnTemp?.trigger;
    const act = state.learnTemp?.action;
    if(tgr && act){
      await saveSkill(tgr, act);
      state.learnTemp = null;
      setStatus("");
      addMsg(`âœ… Learned:\n"${normAlias(tgr)}" â†’ ${act}`, "bot");
      setChips(["LISTSKILLS","HELP"]);
      return;
    }
    setStatus("");
    addMsg("Couldnâ€™t save that. Try again.", "bot");
    return;
  }

  // BULK flow
  if(U === "BULK"){
    bulk.waiting = true;
    bulk.parsed = null;
    setStatus("");
    addMsg(
      "BULK IMPORT MODE\n\nPaste a block next.\n\nAliases format:\n  john rush = AbCdEf123\n\nSkills format:\n  monthly gross -> REVENUE MONTH\n\nAfter paste: BULK CONFIRM or BULK CANCEL",
      "bot"
    );
    setChips(["BULK CANCEL","HELP"]);
    return;
  }
  if(U === "BULK CANCEL"){
    bulk.waiting = false;
    bulk.parsed = null;
    setStatus("");
    addMsg("Bulk import cancelled.", "bot");
    setChips(["HELP","NEXT","UNPAID"]);
    return;
  }
  if(U === "BULK CONFIRM"){
    if(!bulk.parsed || !bulk.parsed.items?.length){
      setStatus("");
      addMsg("No bulk data to import. Type BULK then paste your block first.", "bot");
      return;
    }
    setStatus("Importingâ€¦");
    try{
      if(bulk.parsed.mode === "ALIASES"){
        await bulkWriteAliases(bulk.parsed.items);
        setStatus("");
        addMsg(`âœ… Imported ${bulk.parsed.items.length} nickname(s).`, "bot");
        setChips(["ALIASES","HELP"]);
      }else if(bulk.parsed.mode === "SKILLS"){
        await bulkWriteSkills(bulk.parsed.items);
        setStatus("");
        addMsg(`âœ… Imported ${bulk.parsed.items.length} learned command(s).`, "bot");
        setChips(["LISTSKILLS","HELP"]);
      }else{
        setStatus("");
        addMsg("I couldnâ€™t detect the bulk type. Use '=' for aliases or '->' for skills.", "bot");
        setChips(["BULK","HELP"]);
      }
      bulk.parsed = null;
    }catch(e){
      setStatus("");
      addMsg("Bulk import failed: " + (e?.message || String(e)), "bot");
    }
    return;
  }

  // HELP
  if(U === "HELP"){
    setStatus("");
    addMsg(helpText(), "bot");
    setChips(["NEXT","UNPAID","UNFINISHED","MONTHLY GROSS","SHOWALL","DBSCAN","SCANFIX","BULK","ALIASES","LISTSKILLS"]);
    return;
  }

  // LISTSKILLS / FORGET
  if(U === "LISTSKILLS"){
    const skills = await ensureSkillsFresh();
    setStatus("");
    if(!skills.length){ addMsg("No learned commands yet.", "bot"); return; }
    addMsg(
      `Learned commands (showing ${Math.min(80,skills.length)}):\n` +
      skills.slice(0,80).map(s=>`â€¢ "${s.trigger}" â†’ ${s.action}`).join("\n"),
      "bot"
    );
    setChips(["HELP","BULK"]);
    return;
  }
  if(U.startsWith("FORGET ")){
    const trig = clean(text.slice(7));
    if(!trig){ setStatus(""); addMsg("Usage: FORGET <trigger>", "bot"); return; }
    await deleteSkillByTrigger(trig);
    setStatus("");
    addMsg(`ðŸ§½ Forgot trigger: "${normAlias(trig)}"`, "bot");
    setChips(["LISTSKILLS","HELP"]);
    return;
  }

  // ALIASES / UNNICK / NICK
  if(U === "ALIASES"){
    const a = await listAliases(200);
    setStatus("");
    if(!a.length){ addMsg("No nicknames yet. Use: NICK <id> <name>", "bot"); return; }
    addMsg("Nicknames:\n" + a.slice(0,200).map(x=>`â€¢ "${x.alias}" â†’ ${x.orderId}`).join("\n"), "bot");
    setChips(["HELP","NEXT"]);
    return;
  }
  if(U.startsWith("UNNICK ")){
    const aliasText = clean(text.slice(7));
    if(!aliasText){ setStatus(""); addMsg("Usage: UNNICK <nickname>", "bot"); return; }
    await deleteAlias(aliasText);
    setStatus("");
    addMsg(`ðŸ§½ Removed nickname: "${normAlias(aliasText)}"`, "bot");
    setChips(["ALIASES","HELP"]);
    return;
  }
  if(U.startsWith("NICK ")){
    // NICK <id> <nickname...> OR NICK <nickname...> uses last
    const parts = text.split(/\s+/);
    const maybeId = parts[1] || "";
    let id = "";
    let aliasText = "";

    if(looksLikeId(maybeId)){
      id = maybeId;
      aliasText = parts.slice(2).join(" ");
    }else{
      id = state.lastOrderId;
      aliasText = parts.slice(1).join(" ");
    }

    id = await resolveOrderId(id);
    if(!id){ setStatus(""); addMsg("NICK needs an order (use NEXT or SHOW first, or include id).", "bot"); return; }
    if(!clean(aliasText)){ setStatus(""); addMsg("NICK needs a nickname. Example: NICK john rush", "bot"); return; }

    await setAlias(aliasText, id);
    setStatus("");
    addMsg(`âœ… Saved nickname:\n"${normAlias(aliasText)}" â†’ ${id}`, "bot");
    setChips([`SHOWALL ${normAlias(aliasText)}`, `DONE ${normAlias(aliasText)}`, `SHIPPED ${normAlias(aliasText)}`, "ALIASES"]);
    return;
  }

  // DBSCAN
  if(U === "DBSCAN"){
    setStatus("Scanning databaseâ€¦");
    try{
      const report = await dbScanAll();
      setStatus("");
      addMsg(report, "bot");
      setChips(["SCANFIX","HELP"]);
    }catch(e){
      setStatus("");
      addMsg("DBSCAN failed: " + (e?.message || String(e)), "bot");
    }
    return;
  }

  // SCANFIX
  if(U === "SCANFIX"){
    setStatus("Scanning + building fix planâ€¦");
    try{
      const plan = await buildFixPlan();
      state.pendingFixPlan = plan;
      setStatus("");
      addMsg(
        "SCANFIX REPORT\n" +
        plan.summary.join("\n") + "\n\n" +
        `Fixes queued: ${plan.fixes.length}\n` +
        (plan.fixes.length ? "Type: SCANFIX CONFIRM to apply (safe capped)." : "No fixes needed ðŸŽ‰"),
        "bot"
      );
      setChips(["SCANFIX CONFIRM","DBSCAN","HELP"]);
    }catch(e){
      setStatus("");
      addMsg("SCANFIX failed: " + (e?.message || String(e)), "bot");
    }
    return;
  }
  if(U === "SCANFIX CONFIRM"){
    if(!state.pendingFixPlan || !state.pendingFixPlan.fixes.length){
      setStatus("");
      addMsg("No pending fix plan. Run SCANFIX first.", "bot");
      return;
    }
    setStatus("Applying fixesâ€¦");
    try{
      const res = await applyFixPlan(state.pendingFixPlan);
      state.pendingFixPlan = null;
      bustOrders(); bustSkills(); bustAliases();
      setStatus("");
      addMsg(`âœ… Applied fixes: ${res.ok}/${res.total}\nFailed: ${res.fail}`, "bot");
      setChips(["DBSCAN","HELP"]);
    }catch(e){
      setStatus("");
      addMsg("Apply failed: " + (e?.message || String(e)), "bot");
    }
    return;
  }

  // Revenue / totals
  if(U.startsWith("REVENUE ")){
    const range = upper(text.split(/\s+/)[1]||"MONTH");
    const rows = await ensureOrdersFresh();
    const pred = (range==="TODAY") ? isToday : (range==="WEEK" ? isThisWeek : isThisMonth);
    const inRange = rows.filter(pred);
    const done = inRange.filter(r=>normalizeStatus(r.status)==="done");
    const revenue = done.reduce((s,r)=>s+orderTotal(r),0);
    setStatus("");
    addMsg(`REVENUE ${range}\n${money(revenue)} (done orders only)`, "bot");
    setChips(["REVENUE MONTH","REVENUE WEEK","TOTALS MONTH","HELP"]);
    return;
  }
  if(U.startsWith("TOTALS ")){
    const range = upper(text.split(/\s+/)[1]||"MONTH");
    const rows = await ensureOrdersFresh();
    const pred = (range==="TODAY") ? isToday : (range==="WEEK" ? isThisWeek : isThisMonth);
    const inRange = rows.filter(pred);
    const done = inRange.filter(r=>normalizeStatus(r.status)==="done");
    const revenue = done.reduce((s,r)=>s+orderTotal(r),0);
    setStatus("");
    addMsg(`TOTALS ${range}\nOrders: ${inRange.length}\nDone: ${done.length}\nRevenue (done only): ${money(revenue)}`, "bot");
    setChips(["TOTALS MONTH","TOTALS WEEK","REVENUE MONTH","HELP"]);
    return;
  }

  // Lists
  const listCmds = ["UNFINISHED","NEW","PENDING","UNPAID","DONE","TODAY","WEEK","MONTH","PRIORITY"];
  const cmd0 = upper(text.split(/\s+/)[0]||"");
  if(listCmds.includes(cmd0)){
    const rows = await ensureOrdersFresh();
    let out = rows.slice();

    if(cmd0 === "UNFINISHED") out = out.filter(r=>!["done","archived","cancelled","refunded"].includes(normalizeStatus(r.status)));
    if(cmd0 === "NEW") out = out.filter(r=>normalizeStatus(r.status)==="new");
    if(cmd0 === "PENDING") out = out.filter(r=>normalizeStatus(r.status)==="pending");
    if(cmd0 === "UNPAID") out = out.filter(r=>normalizeStatus(r.status)==="unpaid");
    if(cmd0 === "DONE") out = out.filter(r=>normalizeStatus(r.status)==="done");
    if(cmd0 === "TODAY") out = out.filter(isToday);
    if(cmd0 === "WEEK") out = out.filter(isThisWeek);
    if(cmd0 === "MONTH") out = out.filter(isThisMonth);

    if(cmd0 === "PRIORITY"){
      out = out.filter(r=>!["done","archived","cancelled","refunded"].includes(normalizeStatus(r.status)));
      out.sort((a,b)=>{
        const sa = priorityScore(a), sb = priorityScore(b);
        if(sa !== sb) return sa - sb;
        return orderCreatedDate(a).getTime() - orderCreatedDate(b).getTime();
      });
    }else{
      out.sort((a,b)=>orderCreatedDate(b).getTime() - orderCreatedDate(a).getTime());
    }

    out = out.slice(0, 60);
    setStatus("");
    addMsg(formatOrderList(out, cmd0), "bot");
    setChips(["NEXT","UNPAID","UNFINISHED","PRIORITY","HELP","SHOWALL "+(state.lastOrderId||"")].filter(Boolean));
    return;
  }

  // NEXT
  if(U === "NEXT"){
    const rows = await ensureOrdersFresh();
    const next = pickNext(rows);
    setStatus("");
    if(!next){ addMsg("NEXT: none found ðŸŽ‰", "bot"); return; }
    state.lastOrderId = next.id;
    addMsg(orderCard(next.id, next), "bot");
    setChips([`NICK ${next.id} `,`DONE ${next.id}`,`SHIPPED ${next.id}`,`PAID ${next.id}`,`SHOWALL ${next.id}`,"UNPAID","UNFINISHED","HELP"]);
    return;
  }

  // SHOW / SHOWALL
  if(U.startsWith("SHOWALL ")){
    const token = clean(text.slice(8)) || state.lastOrderId;
    const id = await resolveOrderId(token);
    if(!id){ setStatus(""); addMsg("SHOWALL needs an id or nickname.", "bot"); return; }
    const snap = await db.collection(ORDERS).doc(id).get();
    setStatus("");
    if(!snap.exists){ addMsg(`Not found: ${id}`, "bot"); return; }
    const data = snap.data();
    state.lastOrderId = id;
    addMsg(orderCard(id, data), "bot");
    setChips([`NICK ${id} `,`DONE ${token||id}`,`SHIPPED ${token||id}`,`PAID ${token||id}`,"NEXT","HELP"]);
    return;
  }

  if(U.startsWith("SHOW ")){
    // SHOW uses same full details now (so you always see everything)
    const token = clean(text.slice(5)) || state.lastOrderId;
    const id = await resolveOrderId(token);
    if(!id){ setStatus(""); addMsg("SHOW needs an id or nickname.", "bot"); return; }
    const snap = await db.collection(ORDERS).doc(id).get();
    setStatus("");
    if(!snap.exists){ addMsg(`Not found: ${id}`, "bot"); return; }
    const data = snap.data();
    state.lastOrderId = id;
    addMsg(orderCard(id, data), "bot");
    setChips([`NICK ${id} `,`DONE ${token||id}`,`SHIPPED ${token||id}`,`PAID ${token||id}`,"NEXT","HELP"]);
    return;
  }

  // DONE / SHIPPED / PAID
  if(U.startsWith("DONE ") || U.startsWith("SHIPPED ") || U.startsWith("PAID ")){
    const parts = text.split(/\s+/);
    const verb = upper(parts[0]);
    const token = clean(parts.slice(1).join(" ")) || state.lastOrderId;
    const id = await resolveOrderId(token);
    if(!id){ setStatus(""); addMsg(`${verb} needs an id or nickname (or use NEXT first).`, "bot"); return; }

    const patch = {};
    if(verb === "DONE"){ patch.status="done"; patch.doneAt=ts(); }
    if(verb === "SHIPPED"){ patch.shippedAt=ts(); }
    if(verb === "PAID"){ patch.paidAt=ts(); }

    await db.collection(ORDERS).doc(id).set(patch, { merge:true });
    bustOrders();
    setStatus("");
    state.lastOrderId = id;
    addMsg(`âœ… ${verb} set for ${id}`, "bot");
    setChips([`SHOWALL ${id}`,"NEXT","UNPAID","HELP"]);
    return;
  }

  // BYPHONE
  if(U.startsWith("BYPHONE ")){
    const digs = digitsOnly(text.slice(8));
    const rows = await ensureOrdersFresh();
    const out = rows.filter(r=>{
      const pd = digitsOnly(r?.order?.phoneDigits || "");
      const p = digitsOnly(r?.order?.phone || "");
      return (pd && pd === digs) || (!pd && p === digs);
    }).sort((a,b)=>orderCreatedDate(b)-orderCreatedDate(a)).slice(0, 120);

    setStatus("");
    addMsg(formatOrderList(out, `BYPHONE ${digs}`), "bot");
    setChips(["NEXT","UNFINISHED","HELP"]);
    return;
  }

  // FIND
  if(U.startsWith("FIND ")){
    const q = lower(text.slice(5));
    const rows = await ensureOrdersFresh();
    const out = rows.filter(r=>JSON.stringify(r).toLowerCase().includes(q))
      .sort((a,b)=>orderCreatedDate(b)-orderCreatedDate(a))
      .slice(0, 120);

    setStatus("");
    addMsg(formatOrderList(out, `FIND "${q}"`), "bot");
    setChips(["NEXT","UNFINISHED","HELP"]);
    return;
  }

  // Not recognized: ask to learn
  setStatus("");
  addMsg("I didnâ€™t recognize that.", "bot");
  state.awaitingLearnConfirm = text;
  addMsg(`Do you want me to learn this as a new command?\n"${text}"\nReply yes or no.`, "bot");
}

/* =========================
   CHAT WRAPPER
   - handles bulk paste
   - checks learned triggers first
========================= */
async function handleChat(raw){
  const text = clean(raw);
  if(!text) return;

  // BULK paste capture
  if(bulk.waiting){
    bulk.waiting = false;
    const parsed = parseBulkBlock(raw);
    bulk.parsed = parsed;

    const n = parsed.items.length;
    const preview = parsed.mode === "ALIASES"
      ? parsed.items.slice(0,10).map(x=>`â€¢ "${x.alias}" â†’ ${x.orderId}`).join("\n")
      : parsed.mode === "SKILLS"
        ? parsed.items.slice(0,10).map(x=>`â€¢ "${x.trigger}" â†’ ${x.action}`).join("\n")
        : "(unknown format)";

    addMsg(
      `BULK PREVIEW (${parsed.mode})\nItems found: ${n}\n\n${preview}\n\nType: BULK CONFIRM to import\nor: BULK CANCEL`,
      "bot"
    );
    setChips(["BULK CONFIRM","BULK CANCEL"]);
    return;
  }

  // Learned triggers first (simple includes match)
  try{
    const skills = await ensureSkillsFresh();
    const L = lower(text);
    for(const s of skills){
      const trig = String(s.trigger||"").toLowerCase();
      if(trig && L.includes(trig)){
        await handleCommand(String(s.action||""));
        return;
      }
    }
  }catch(e){
    // ignore
  }

  // Interpret natural -> command
  const cmd = interpretNatural(text);
  await handleCommand(cmd);
}

/* =========================
   SEND
========================= */
async function send(){
  const raw = input.value;
  input.value = "";
  if(!clean(raw)) return;

  addMsg(raw, "user");
  try{
    setStatus("");
    await handleChat(raw);
  }catch(err){
    console.error(err);
    setStatus("âš ï¸ " + (err?.message || String(err)));
    addMsg("âš ï¸ Something broke. Try HELP.", "bot");
    setChips(["HELP","NEXT","UNPAID"]);
  }
}

/* Events */
document.getElementById("sendBtn").addEventListener("click", send);
input.addEventListener("keydown", (e)=>{ if(e.key === "Enter") send(); });

document.getElementById("resetBtn").addEventListener("click", ()=>{
  chat.innerHTML = "";
  setStatus("");
  state.lastOrderId = "";
  state.awaitingLearnConfirm = null;
  state.awaitingLearnAction = null;
  state.learnTemp = null;
  state.pendingFixPlan = null;
  bulk.waiting = false;
  bulk.parsed = null;

  setChips(["HELP","NEXT","UNPAID","UNFINISHED","MONTHLY GROSS","SHOWALL","DBSCAN","SCANFIX","BULK","ALIASES","LISTSKILLS"]);
  addMsg("Reset âœ…\nTry: NEXT, showall <nickname>, unpaid, bulk", "bot");
});

/* Boot */
(function init(){
  setChips(["HELP","NEXT","UNPAID","UNFINISHED","MONTHLY GROSS","SHOWALL","DBSCAN","SCANFIX","BULK","ALIASES","LISTSKILLS","PRIORITY"]);
  addMsg(
`Howdy ðŸ¤ 
This admin bot shows EVERYTHING stored on an order.

Try:
â€¢ NEXT
â€¢ showall <id or nickname>
â€¢ nick john rush
â€¢ aliases
â€¢ bulk
â€¢ monthly gross
â€¢ dbscan
â€¢ scanfix`,
  "bot"
  );
  setStatus("âœ… Ready");
})();
</script>
</body>
</html>
